# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Indicadors_Habitatge
                                 A QGIS plugin
 Indicadors_Habitatge
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-01
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Josep López
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys
import os
import processing
from os.path import expanduser
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import QAction, QMessageBox, QTableWidgetItem, QApplication, QToolBar, QColorDialog, QFileDialog
from qgis.core import QgsMapLayer
from qgis.core import QgsDataSourceUri
from qgis.core import QgsVectorLayer
from qgis.core import QgsFeatureRequest
from qgis.core import QgsField
from qgis.core import QgsPoint
from qgis.core import QgsPointXY
from qgis.core import QgsFeatureRenderer
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsGradientColorRamp
from qgis.core import QgsProject
from qgis.core import QgsRendererRange
from qgis.core import QgsSymbol
from qgis.core import QgsFillSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsSymbolLayerRegistry
from qgis.core import QgsRandomColorRamp
from qgis.core import QgsRendererRangeLabelFormat
from qgis.core import QgsProject
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsRenderContext
from qgis.core import QgsPalLayerSettings
from qgis.core import QgsTextFormat
from qgis.core import QgsTextBufferSettings
from qgis.core import QgsVectorLayerSimpleLabeling
from qgis.core import QgsWkbTypes
from qgis.core import QgsVectorLayerExporter
from qgis.core import QgsProcessingFeedback
from qgis.core import QgsFeature
from qgis.core import Qgis
import psycopg2
import unicodedata
import datetime
import time
import qgis.utils
from qgis.utils import iface
from PyQt5.QtSql import *
import datetime
import time

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Indicadors_Habitatge_dialog import Indicadors_HabitatgeDialog
import os.path
from itertools import dropwhile

"""
Variables globals per a la connexio
i per guardar el color dels botons
"""
Versio_modul = "V_Q3.210326"
nomBD1 = ""
contra1 = ""
host1 = ""
port1 = ""
usuari1 = ""
schema = ""
Fitxer = ""
cur = None
conn = None
Path_Inicial = expanduser("~")
TEMPORARY_PATH=""

class Indicadors_Habitatge:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Indicadors_Habitatge_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = Indicadors_HabitatgeDialog()

        self.dlg.bt_sortir.clicked.connect(self.on_click_Sortir)
        self.dlg.bt_inici.clicked.connect(self.on_click_Inici)
        self.dlg.comboConnexio.currentIndexChanged.connect(self.on_Change_ComboConn)
        self.dlg.color.clicked.connect(self.on_click_Color)
        self.dlg.colorTag.clicked.connect(self.on_click_ColorEtiqueta)
        self.dlg.CB_etiquetes.stateChanged.connect(self.on_checkAddTags)
        self.dlg.RB_color.toggled.connect(self.on_checkRB_color)
        self.dlg.RB_degradat.toggled.connect(self.on_checkRB_degradat)
        self.dlg.Transparencia.valueChanged.connect(self.on_valuechange_Transparencia)
        self.dlg.tabWidget.currentChanged.connect(self.on_currentchange_tab)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr('&CCU')
        # TODO: We are going to let the user set this up in a future iteration
        # self.toolbar = self.iface.addToolBar('CCU')
        # self.toolbar.setObjectName('Indicadors_Habitatge')

        trobat = False
        for x in iface.mainWindow().findChildren(QToolBar, 'CCU'):
            self.toolbar = x
            trobat = True

        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Indicadors_Habitatge', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Indicadors_Habitatge/icon.png'
        self.add_action(
            icon_path,
            text=self.tr('Indicadors_Habitatge'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def on_click_Sortir(self):
        '''
        Tanca la finestra del plugin 
        '''
        self.estatInicial()
        self.dlg.close()

    def getConnections(self):
        """Aquesta funcio retorna les connexions que estan guardades en el projecte."""
        s = QSettings()
        s.beginGroup("PostgreSQL/connections")
        currentConnections = s.childGroups()
        s.endGroup()
        return currentConnections

    def populateComboBox(self, combo, list, predef, sort):
        """Procediment per omplir el combo especificat amb la llista suministrada"""
        combo.blockSignals(True)
        combo.clear()
        model = QStandardItemModel(combo)
        predefInList = None
        for elem in list:
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        if sort:
            model.sort(0)
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0, predef)
                combo.setCurrentIndex(0)
        combo.blockSignals(False)

    def setButtonChecked(self, boto):
        '''
        Funció auxiliar per canviar aparença de botons
        '''
        boto.setChecked(True)
        boto.setStyleSheet('background-color: rgb(85, 255, 127)')

    def setButtonUnchecked(self, boto):
        '''
        Funció auxiliar per canviar aparença de botons
        '''
        boto.setChecked(False)
        boto.setStyleSheet('background-color: rgb(255, 156, 156)')

    def on_currentchange_tab(self):
        if self.dlg.tabWidget.currentIndex() == 2:
            self.dlg.Metodes.setEnabled(False)
        else:
            self.dlg.Metodes.setEnabled(True)

    def on_Change_ComboConn(self):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de les connexions,
        automàticament comprova si es pot establir
        connexió amb la bbdd seleccionada.
        """
        global aux
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global schema
        global cur
        global conn
        s = QSettings()
        select = 'Selecciona connexió'
        nom_conn = self.dlg.comboConnexio.currentText()

        if nom_conn != select:
            aux = True
            s.beginGroup("PostgreSQL/connections/" + nom_conn)
            currentKeys = s.childKeys()

            nomBD1 = s.value("database", "")
            contra1 = s.value("password", "")
            host1 = s.value("host", "")
            port1 = s.value("port", "")
            usuari1 = s.value("username", "")
            schema = 'public'

            self.barraEstat_connectant()
            self.dlg.lblEstatConn.setAutoFillBackground(True)
            QApplication.processEvents()

            # Connexio
            nomBD = nomBD1.encode('ascii', 'ignore')
            usuari = usuari1.encode('ascii', 'ignore')
            servidor = host1.encode('ascii', 'ignore')
            contrasenya = contra1.encode('ascii', 'ignore')
            try:
                estructura = "dbname='" + nomBD.decode("utf-8") + "' user='" + usuari.decode(
                    "utf-8") + "' host='" + servidor.decode("utf-8") + "' password='" + contrasenya.decode(
                    "utf-8") + "'"  # schema='"+schema+"'"
                conn = psycopg2.connect(estructura)
                self.barraEstat_connectat()
                cur = conn.cursor()


            except Exception as ex:
                print("I am unable to connect to the database")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print(message)
                QMessageBox.information(None, "Error", "Error canvi connexió")
                conn.rollback()
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return


        else:
            aux = False
            self.barraEstat_noConnectat()

    def ompleCombos(self, combo, llista, predef):
        """Aquesta funció omple els combos que li passem per paràmetres"""
        combo.blockSignals(True)
        combo.clear()
        model = QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                if isinstance(elem, tuple):
                    item = QStandardItem(unicode(elem[0]))
                else:
                    item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem[0]))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0, predef)
                combo.setCurrentIndex(0)
        combo.blockSignals(False)

    def estatInicial(self):
        '''
        @param self:
        Resteja tots els valors per defecte del plugin: estat inicial.
        '''
        global micolor
        global micolorTag
        global aux
        global Versio_modul
        global itemSel
        global lbl_Cost
        global TEMPORARY_PATH
        aux = False
        itemSel = None
        self.barraEstat_noConnectat()
        self.dlg.versio.setText(Versio_modul)
        self.dlg.Cmb_Metode.setCurrentIndex(0)
        self.dlg.tabWidget.setCurrentIndex(0)
        self.dlg.RB_color.setChecked(True)
        self.dlg.inverse_ratio.setChecked(False)
        self.dlg.checkbox_media.setChecked(False)
        self.dlg.color.setEnabled(True)
        self.dlg.Transparencia.setEnabled(True)
        self.dlg.comboIndicador.clear;
        self.dlg.comboIndicador_2.clear;
        self.dlg.comboIndicador_3.clear;
        self.dlg.CB_etiquetes.setChecked(False)
        self.dlg.mitjanaRadioButton.setChecked(True)
        self.dlg.mida.setEnabled(False)
        self.dlg.colorTag.setEnabled(False)
        self.dlg.decimals.setEnabled(False)
        self.dlg.min.setEnabled(False)
        self.dlg.max.setEnabled(False)
        self.dlg.Transparencia.setEnabled(True)
        self.dlg.Transparencia_lbl.setText(str(self.dlg.Transparencia.value()) + ' %')
        micolor = QColor(255, 0, 0, 255)
        micolorTag = QColor(128, 0, 128, 255)
        self.dlg.color.setStyleSheet('border:1px solid #000000; background-color: #ff0000')
        self.dlg.colorTag.setStyleSheet('border:1px solid #000000; background-color: #800080')
        self.dlg.min.setValue(500.00)
        self.dlg.max.setValue(50000.00)
        self.progress_changed(0)
        self.dlg.Metodes.setEnabled(True)
        llista = ['DensitatHabitantsHabitatge', 'DensitatHabitatgeÀrea',
                  'DensitatEdificis', 'DensitatPlanta0Area']
        self.ompleCombos(self.dlg.comboIndicador, llista, "Selecciona un indicador")
        llista = ['FinquesAnyConstruccio']
        self.ompleCombos(self.dlg.comboIndicador_2, llista, "Selecciona un indicador")
        llista = ['MapaAlçadesParcel·la']
        self.ompleCombos(self.dlg.comboIndicador_3, llista, "Selecciona un indicador")
        self.SetTooltipIndicadors()
        if (os.name=='nt'):
            TEMPORARY_PATH=os.environ['TMP']
        else:
            TEMPORARY_PATH=os.environ['TMPDIR']

    def SetTooltipIndicadors(self):
        self.dlg.comboIndicador.setItemData(1,"Sup. construïda amb ús d'habitatge/nombre d'habitants",QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(2,"Sup. construïda amb ús d'habitatge/Sup. geomètrica (solar)",QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(3,"Sup. construïda per a qualsevol ús/Sup. geometrica (solar)",QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(4,"Sup. construïda en planta baixa/Sup. geomètrica (solar)",QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador_2.setItemData(1,"Any construcció",QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador_3.setItemData(1,"Nombre de plantes edifici mes alt de la parcel·la",QtCore.Qt.ToolTipRole)


    def on_checkRB_color(self, enabled):
        if enabled:
            self.dlg.color.setEnabled(True)
            self.dlg.Transparencia.setEnabled(True)
        else:
            self.dlg.color.setEnabled(False)
            self.dlg.Transparencia.setEnabled(True)

    def on_checkAddTags(self, state):
        '''Aquesta funcio habilita o deshabilitat els diferents elements de les etiquetes'''
        if state != QtCore.Qt.Checked:
            self.dlg.mida.setEnabled(False)
            self.dlg.colorTag.setEnabled(False)
            self.dlg.decimals.setEnabled(False)
            self.dlg.min.setEnabled(False)
            self.dlg.max.setEnabled(False)
        else:
            self.dlg.mida.setEnabled(True)
            self.dlg.colorTag.setEnabled(True)
            self.dlg.decimals.setEnabled(True)
            self.dlg.min.setEnabled(True)
            self.dlg.max.setEnabled(True)

    def on_click_ColorEtiqueta(self):
        """Aquesta funció obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolorTag
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorTag = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolorTag.name()
        self.dlg.colorTag.setStyleSheet(estilo)
        self.dlg.colorTag.setAutoFillBackground(True)
        pep = self.dlg.colorTag.palette().color(1)
        pass

    def on_checkRB_degradat(self, enabled):
        if enabled:
            self.dlg.ColorDegradat.setEnabled(True)
            self.dlg.LE_rang.setEnabled(True)
            self.dlg.combo_Tipus.setEnabled(True)
        else:
            self.dlg.ColorDegradat.setEnabled(False)
            self.dlg.LE_rang.setEnabled(False)
            self.dlg.combo_Tipus.setEnabled(False)

    def on_valuechange_Transparencia(self):
        """Aquesta es una funcio auxiliar que canvia el valor de la etiqueta associada a la transperencia de la capa escollida"""
        self.dlg.Transparencia_lbl.setText(str(self.dlg.Transparencia.value()) + ' %')

    def on_click_ColorEtiqueta(self):
        """Aquesta funció obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolorTag
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorTag = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolorTag.name()
        self.dlg.colorTag.setStyleSheet(estilo)
        self.dlg.colorTag.setAutoFillBackground(True)
        pep = self.dlg.colorTag.palette().color(1)
        pass

    def on_click_Color(self):
        """Aquesta funció obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolor
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolor = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolor.name()
        self.dlg.color.setStyleSheet(estilo)
        self.dlg.color.setAutoFillBackground(True)
        pep = self.dlg.color.palette().color(1)
        pass

    def controlErrorsInput(self):
        '''
        Aquesta funció s'encarrega de controlar que quan comenci el càlcul
        totes les entrades de dades estiguin omplertes i siguin correctes
        '''
        global itemSel
        errors = []

        if self.dlg.comboConnexio.currentText() == 'Selecciona connexió':
            errors.append("No hi ha connexió")
        if self.dlg.tabWidget.currentIndex() == 0:
            if self.dlg.Cmb_Metode.currentText() == 'Selecciona Mètode' or self.dlg.Cmb_Metode.currentText() == '':
                errors.append("No hi ha mètode de treball")
            if self.dlg.comboIndicador.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")

        elif self.dlg.tabWidget.currentIndex() == 1:
            if self.dlg.Cmb_Metode.currentText() == 'Selecciona Mètode' or self.dlg.Cmb_Metode.currentText() == '':
                errors.append("No hi ha mètode de treball")
            if self.dlg.comboIndicador_2.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")
        else:
            if self.dlg.comboIndicador_3.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")
        return errors

    def getIndicador(self, fitxer):
        currentComboText = self.dlg.comboIndicador.currentText()
        if currentComboText == 'DensitatHabitantsHabitatge':
            return '''SELECT "parcel"."id", "parcel"."geom", "parcel"."UTM",  fus."Superficie_Cons" AS "SupCons",  tr."Habitants"
            FROM "parcel"  LEFT JOIN "tr_temp''' + fitxer + '''" AS tr ON "parcel"."UTM" = tr."Parcela" LEFT JOIN (SELECT * FROM  "FinquesUS" WHERE "Us" LIKE 'V') AS fus ON "parcel"."UTM" = fus."UTM"
            WHERE fus."Superficie_Cons" IS NOT NULL AND tr."Habitants" IS NOT NULL'''
        elif currentComboText == 'DensitatHabitatgeÀrea':
            return '''SELECT "parcel"."id", "parcel"."geom", "parcel"."UTM",  fus."Superficie_Cons" AS "SupCons", ST_Area(geom)
            FROM "parcel" LEFT JOIN (SELECT * FROM  "FinquesUS" WHERE "Us" LIKE 'V') AS fus ON "parcel"."UTM" = fus."UTM"
            WHERE fus."Superficie_Cons" IS NOT NULL'''
        elif currentComboText == 'DensitatEdificis':
            return '''SELECT ROW_NUMBER () OVER (ORDER BY "parcel"."UTM") AS "id", "parcel"."geom", "parcel"."UTM",  SUM(fus."Superficie_Cons"::INTEGER) AS "SupCons"
            FROM "parcel" LEFT JOIN "FinquesUS" AS fus ON "parcel"."UTM" = fus."UTM"
            WHERE fus."Superficie_Cons" IS NOT NULL
            GROUP BY "parcel"."geom", "parcel"."UTM"'''
        elif currentComboText == 'DensitatPlanta0Area':
            return '''SELECT ROW_NUMBER () OVER (ORDER BY "parcel"."UTM") AS "id", "parcel"."geom", "parcel"."UTM", SUM(fp."Superficie_cons"::INTEGER) AS "SupCons", "Pis"
            FROM "parcel" LEFT JOIN (SELECT * FROM  "FinquesPlantes" WHERE "Pis" IN ('0', '00','BX', 'BJ', 'OD', 'OP', 'OA') OR ("Pis" LIKE 'UE' AND "Escala" LIKE 'S')) AS fp ON "parcel"."UTM" = fp."UTM"
            WHERE fp."Superficie_cons" IS NOT NULL AND fp."Superficie_cons" NOT LIKE '0' 
            GROUP BY "parcel"."geom", "parcel"."UTM", "Pis"'''


    def getIndicador2(self):
        currentComboText = self.dlg.comboIndicador_2.currentText()
        if currentComboText == 'FinquesAnyConstruccio':
            return '''SELECT ROW_NUMBER () OVER (ORDER BY "parcel"."UTM") AS "id", "parcel"."geom", "parcel"."UTM",
            SUM(fus."Superficie_Cons"::INTEGER) AS "SupCons",
            fac."Any_constr", (SUM(fus."Superficie_Cons"::INTEGER) * fac."Any_constr"::INTEGER) AS "SCxAC"
            FROM "parcel" LEFT JOIN "FinquesUS" AS fus ON "parcel"."UTM" = fus."UTM"
            LEFT JOIN (SELECT "UTM", MAX("Any_constr") AS "Any_constr"
            FROM  "FinquesAnyConstruccio"  
            WHERE "Any_constr" 
            BETWEEN \'''' + str(int(self.dlg.any_inici.value())) + '\' AND \'' + str(int(self.dlg.any_fi.value())) + '''\'
            GROUP BY "UTM") AS fac ON "parcel"."UTM" = fac."UTM" 
            WHERE fus."Superficie_Cons" IS NOT NULL AND fac."Any_constr" IS NOT NULL 
            GROUP BY "parcel"."geom", "parcel"."UTM", fac."Any_constr"'''


    def getIndicador3(self):
        currentComboText = self.dlg.comboIndicador_3.currentText()
        if currentComboText == 'MapaAlçadesParcel·la':
            return '''SELECT ROW_NUMBER () OVER (ORDER BY "parcel"."id") AS "id", "parcel"."geom", "parcel"."UTM", alt."Indicador", alt."Pis", alt."SupCons"
            FROM "parcel" LEFT JOIN
            (SELECT "UTM", MAX(
            CASE
            WHEN "Pis" ~ '^[0-9\.]+$' THEN
            CAST ("Pis" AS INTEGER)
            ELSE
            0
            END)+1 AS "Indicador", "Pis",
            SUM("Superficie_cons"::INTEGER) AS "SupCons"
            FROM "FinquesPlantes"
            WHERE "Pis" ~ '^[0-9\.]+$' OR "Pis" IN ('0', '00','BX', 'BJ', 'OD', 'OP', 'OA') OR ("Pis" LIKE 'UE' AND "Escala" LIKE 'S')
            GROUP BY "UTM", "Pis")
            AS alt ON "parcel"."UTM" = alt."UTM" 
            WHERE alt."Indicador" IS NOT NULL AND alt."SupCons" != 0 
            ORDER BY 4'''

    def getUnitats(self):
        if self.dlg.tabWidget.currentIndex() == 0:
            if (self.dlg.checkbox_media.isChecked()):
                return "%"
            currentComboText = self.dlg.comboIndicador.currentText()
        elif self.dlg.tabWidget.currentIndex() == 1:
            currentComboText = self.dlg.comboIndicador_2.currentText()
        else:
            currentComboText = self.dlg.comboIndicador_3.currentText()

        if currentComboText == 'DensitatHabitantsHabitatge':
            if not self.dlg.inverse_ratio.isChecked():
                return "hab/m^2 x 10000"
            else:
                return "m^2/hab"
        elif currentComboText == 'DensitatHabitatgeÀrea':
            if not self.dlg.inverse_ratio.isChecked():
                return "m^2/m^2"
            else:
                return "m^2/m^2"
        elif currentComboText == 'DensitatEdificis':
            if not self.dlg.inverse_ratio.isChecked():
                return "m^2/m^2"
            else:
                return "m^2/m^2"
        elif currentComboText == 'DensitatPlanta0Area':
            if not self.dlg.inverse_ratio.isChecked():
                return "m^2/m^2"
            else:
                return "m^2/m^2"
        elif currentComboText == 'FinquesAnyConstruccio':
            return ""
        elif currentComboText == 'MapaAlçadesParcel·la':
            return ""
        return ""

    def mostraSHPperPantalla(self, vlayer, capa):
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global micolorTag
        global TEMPORARY_PATH
        uri = QgsDataSourceUri()
        try:
            QApplication.processEvents()
            if vlayer.isValid():
                QApplication.processEvents()
                Area = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
                """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
                if (qgis.utils.Qgis.QGIS_VERSION_INT >= 31000):
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"
                    transform_context = QgsProject.instance().transformContext()
                    error = QgsVectorFileWriter.writeAsVectorFormatV2(vlayer,
                                                                      TEMPORARY_PATH + "/Area_" + Area + ".shp",
                                                                      transform_context, save_options)
                else:
                    error = QgsVectorFileWriter.writeAsVectorFormat(vlayer,
                                                                    TEMPORARY_PATH + "/Area_" + Area + ".shp",
                                                                    "utf-8", vlayer.crs(), "ESRI Shapefile")
                vlayer = None
                """Es carrega el Shape a l'entorn del QGIS"""
                vlayer = QgsVectorLayer(TEMPORARY_PATH + "/Area_" + Area + ".shp", capa, "ogr")
                symbols = vlayer.renderer().symbols(QgsRenderContext())
                symbol = symbols[0]
                if self.dlg.RB_color.isChecked():
                    symbol.setColor(self.dlg.color.palette().color(1))
                    vlayer.setOpacity(self.dlg.Transparencia.value() / 100)
                else:
                    if self.dlg.tabWidget.currentIndex() != 1:
                        fieldname = "Indicador"
                    else:
                        fieldname = "Any_constr"
                    template = "%1 - %2 " + self.getUnitats()

                    numberOfClasses = int(float(self.dlg.LE_rang.value()))
                    myRangeList = []
                    mysymbol = QgsFillSymbol()
                    if (self.dlg.ColorDegradat.currentText() == 'Gris'):
                        colorRamp = QgsGradientColorRamp(QColor(230, 230, 230), QColor(60, 60, 60))
                    elif (self.dlg.ColorDegradat.currentText() == 'Vermell'):
                        colorRamp = QgsGradientColorRamp(QColor(255, 154, 154), QColor(154, 0, 0))
                    elif (self.dlg.ColorDegradat.currentText() == 'Groc'):
                        colorRamp = QgsGradientColorRamp(QColor(255, 255, 154), QColor(154, 154, 0))
                    elif (self.dlg.ColorDegradat.currentText() == 'Blau'):
                        colorRamp = QgsGradientColorRamp(QColor(154, 255, 255), QColor(0, 0, 154))
                    elif (self.dlg.ColorDegradat.currentText() == 'Verd'):
                        colorRamp = QgsGradientColorRamp(QColor(154, 255, 154), QColor(0, 154, 0))

                    format = QgsRendererRangeLabelFormat()

                    precision = 3
                    if self.dlg.tabWidget.currentIndex() == 1:
                        precision = 0
                    format.setFormat(template)
                    format.setPrecision(precision)
                    format.setTrimTrailingZeroes(False)
                    if (self.dlg.combo_Tipus.currentText() == 'Quantil'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Quantile,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Interval igual'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.EqualInterval,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Ruptures naturals'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Jenks, mysymbol,
                                                                             colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Desviació estandard'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.StdDev,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Pretty breaks'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Pretty,
                                                                             mysymbol, colorRamp)
                    renderer.setLabelFormat(format, True)
                    vlayer.setOpacity(self.dlg.Transparencia.value() / 100)
                    vlayer.setRenderer(renderer)
                    QApplication.processEvents()

                if self.dlg.CB_etiquetes.isChecked():
                    layer_settings = QgsPalLayerSettings()
                    text_format = QgsTextFormat()

                    text_format.setFont(QFont("Arial", self.dlg.mida.value()))
                    text_format.setSize(self.dlg.mida.value())

                    text_format.setColor(QColor.fromRgb(micolorTag.red(), micolorTag.green(), micolorTag.blue()))
                    layer_settings.setFormat(text_format)

                    layer_settings.isExpression = True
                    if self.dlg.tabWidget.currentIndex() != 1:
                        layer_settings.fieldName = "to_string(round( \"Indicador\"," + str(self.dlg.decimals.value()) + "))"
                    else:
                        layer_settings.fieldName = "to_string(round( \"Any_constr\"," + str(
                            self.dlg.decimals.value()) + "))"
                    if self.dlg.checkbox_media.isChecked() and self.dlg.tabWidget.currentIndex() == 0:
                        layer_settings.fieldName += "+'%'"
                    QApplication.processEvents()

                    layer_settings.placement = 1
                    layer_settings.scaleVisibility = True
                    layer_settings.minimumScale = float(self.dlg.max.value())
                    layer_settings.maximumScale = float(self.dlg.min.value())
                    layer_settings.enabled = True

                    settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    vlayer.setLabelsEnabled(True)
                    vlayer.setLabeling(settings)
                    vlayer.setScaleBasedVisibility(True)

                    vlayer.triggerRepaint()

                QApplication.processEvents()
                QgsProject.instance().addMapLayer(vlayer, False)
                root = QgsProject.instance().layerTreeRoot()
                myLayerNode = QgsLayerTreeLayer(vlayer)
                root.insertChildNode(0, myLayerNode)
                myLayerNode.setCustomProperty("showFeatureCount", True)
                iface.mapCanvas().refresh()
            else:
                print("Error vector layer")
            QApplication.processEvents()
        except Exception as ex:
            print("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            self.progress_changed(0)
            self.dlg.setEnabled(True)
            self.barraEstat_connectat()
            QMessageBox.information(None, "Error",
                                    "Error mostrant el vlayer per pantalla.")

    def getIndexField(self, vlayer, fieldName):
        fields = vlayer.fields()
        for x in range(len(fields)):
            if (fields[x].displayName() == fieldName):
                return x
        return -1

    def comprobarValidez(self, vlayer):
        parameters = {'ERROR_OUTPUT': 'memory:',
                      'INPUT_LAYER': vlayer,
                      'INVALID_OUTPUT': 'memory:',
                      'METHOD': 2,
                      'VALID_OUTPUT': 'memory:'}

        result = processing.run('qgis:checkvalidity', parameters)

        return result['VALID_OUTPUT']

    def procesoModaPonderada(self, vlayer):
        f = QgsProcessingFeedback()
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'


        parameters = {'CATEGORIES_FIELD_NAME': ['Any_constr','id_agrupat'],
                      'INPUT': vlayer,
                      'OUTPUT': sortida,
                      'VALUES_FIELD_NAME': 'SupCons'}
        result = processing.run('qgis:statisticsbycategories', parameters)

        parameters = {
            'INPUT': result['OUTPUT'],
            'GROUP_BY': 'id_agrupat',
            'AGGREGATES': [{'aggregate': 'concatenate',
                            'delimiter': '',
                            'input': 'if(sum=maximum(sum,group_by:=id_agrupat),\"Any_constr\",\'\')',
                            'length': -1,
                            'name': 'Any',
                            'precision': -1,
                            'type': 10},
                           {'aggregate': 'first_value',
                            'delimiter': ',',
                            'input': '\"id_agrupat\"',
                            'length': 0,
                            'name': 'id_agrupat',
                            'precision': 0,
                            'type': 4}],
            'OUTPUT': sortida
        }
        result = processing.run('qgis:aggregate', parameters, feedback=f)

        parameters = {
            'INPUT': vlayer,
            'INPUT_2': result['OUTPUT'],
            'DISCARD_NONMATCHING': False,
            'FIELD': 'id_agrupat',
            'FIELDS_TO_COPY': ['Any'],
            'FIELD_2': 'id_agrupat',
            'METHOD':1,
            'PREFIX':'',
            'OUTPUT': sortida
        }
        result = processing.run('native:joinattributestable', parameters, feedback=f)

        return result['OUTPUT']


    def MediaPonderada(self, vlayer):
        vlayer.startEditing()
        vlayer.addAttribute(QgsField('Any_constr', QVariant.Int))
        vlayer.commitChanges()
        vlayer.updateFields()

        vlayer.startEditing()
        features = vlayer.getFeatures()
        index = self.getIndexField(vlayer, "Any_constr")
        for feature in features:
            unitat = int(feature.attribute("SCxAC"))
            supCons = feature.attribute("SupCons")
            if type(supCons) is QVariant:
                supCons = supCons.Double
            else:
                supCons = float(supCons)

            if supCons == 0:
                value = 0
            else:
                value = unitat / supCons
            vlayer.changeAttributeValue(feature.id(), index, value)
        vlayer.commitChanges()
        return vlayer


    def on_click_Inici(self):
        '''
        FUNCIÓ DE CÀLCUL PRINCIPAL
        S'encarrega de fer el càlcul de les N-entitats més properes a l'adreça escollida per l'usuari
        i mostrar per pantalla, tan en el mapa com en el quadre del mòdul, els diferents resultats.
        '''
        global cur
        global conn
        global itemSel
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1

        global lbl_Cost
        global Fitxer
        global TEMPORARY_PATH

        QApplication.processEvents()
        Fitxer = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
        self.progress_changed(0)

        '''Control d'errors'''
        llistaErrors = self.controlErrorsInput()
        if len(llistaErrors) > 0:
            llista = "Llista d'errors:\n\n"
            for i in range(0, len(llistaErrors)):
                llista += ("- " + llistaErrors[i] + '\n')
            QMessageBox.information(None, "Error", llista)
            self.dlg.setEnabled(True)
            return

        self.barraEstat_processant()

        self.dlg.setEnabled(False)
        uri = QgsDataSourceUri()
        try:
            uri.setConnection(host1, port1, nomBD1, usuari1, contra1)
        except Exception as ex:
            print("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.dlg.setEnabled(True)
            self.progress_changed(0)
            self.barraEstat_connectat()
            return

        if self.dlg.tabWidget.currentIndex() == 0:
            sql = self.getIndicador(Fitxer)
            indicador = self.dlg.comboIndicador.currentText()
        elif self.dlg.tabWidget.currentIndex() == 1:
            sql = self.getIndicador2()
            indicador = self.dlg.comboIndicador_2.currentText()
        else:
            sql = self.getIndicador3()
            indicador = self.dlg.comboIndicador_3.currentText()
        QApplication.processEvents()
        self.progress_changed(5)

        uri.setDataSource("", "(" + sql + ")", "geom", "", "id")
        if self.dlg.tabWidget.currentIndex() == 2:
            capa = "PARCELES"
        else:
            capa = self.dlg.Cmb_Metode.currentText()

        '''Buscar archivo de parcelas'''
        if self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge' and self.dlg.tabWidget.currentIndex() == 0:
            path = QFileDialog.getExistingDirectory(self.dlg,
                                                    "Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",
                                                    Path_Inicial + "/",
                                                    QFileDialog.ShowDirsOnly)
            trobat = True
            a = time.time()
            while trobat:
                if (path != ''):
                    if (os.path.exists(path + "/tr_parceles.csv")):
                        trobat = False

                        arxiu = open(path + "/tr_parceles.csv", 'r')
                        dummy = arxiu.readline()
                        lines = arxiu.readlines()
                        try:
                            """Creació de la taula temporal Resum_Temp_(data) de les dades del CSV de la taula resum de parceles"""
                            cur.execute(
                                "CREATE TABLE \"tr_temp" + Fitxer + "\" (\"Parcela\" varchar(20), \"Habitants\" numeric);")
                            conn.commit()
                            insert = ""
                            for linia in lines:
                                vec = linia.split(';', 20)
                                insert += "INSERT INTO \"tr_temp" + Fitxer + "\" (\"Parcela\", \"Habitants\") VALUES ('" + \
                                          vec[0] + "', " + vec[1] + ");\n"
                            cur.execute(insert)
                            conn.commit()
                            # print "ok"
                        except Exception as ex:
                            print("Problem reading csv")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print(message)
                            QMessageBox.information(None, "Error", "Problem reading csv")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)

                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet(
                                'border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return

                        arxiu.close()
                        arxiuLlegit = True
                    else:
                        print("No hi ha l'arxiu")
                        path = QFileDialog.getExistingDirectory(self.dlg,
                                                                "Busca la carpeta que conté els arxius provinents del mòdul TAULA RESUM",
                                                                Path_Inicial + "\\", QFileDialog.ShowDirsOnly)
                else:
                    print("Cancelat")
                    self.progress_changed(0)
                    self.dlg.setEnabled(True)
                    self.barraEstat_connectat()
                    return

        self.progress_changed(10)
        QApplication.processEvents()
        vlayer = QgsVectorLayer(uri.uri(False), capa, "postgres")
        vlayer = self.comprobarValidez(vlayer)

        QApplication.processEvents()
        QgsProject.instance().addMapLayer(vlayer, False)


        self.progress_changed(20)
        if self.dlg.tabWidget.currentIndex() == 2 or self.dlg.Cmb_Metode.currentText() == "PARCELES":
            vlayer_resultat = vlayer
        else:
            '''Agregación en función del método de trabajo'''
            if self.dlg.Cmb_Metode.currentText() == "ILLES":
                uri.setDataSource("", "(SELECT * FROM \"ILLES\" WHERE \"D_S_I\" NOT LIKE '' AND \"D_S_I\" IS NOT NULL)",
                                  "geom", "", "id")
            elif self.dlg.Cmb_Metode.currentText() == "PARCELES":
                uri.setDataSource("", "(SELECT * FROM \"parcel\")", "geom", "", "id")
            elif self.dlg.Cmb_Metode.currentText() == "SECCIONS":
                uri.setDataSource("", "(SELECT * FROM \"Seccions\")", "geom", "", "id")
            elif self.dlg.Cmb_Metode.currentText() == "BARRIS":
                uri.setDataSource("", "(SELECT * FROM \"Barris\")", "geom", "", "id")
            elif self.dlg.Cmb_Metode.currentText() == "DISTRICTES POSTALS":
                uri.setDataSource("", "(SELECT * FROM \"DistrictesPostals\")", "geom", "", "id")
            else:
                uri.setDataSource("", "(SELECT * FROM \"Districtes\")", "geom", "", "id")

            entitatResum = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
            entitatResum = self.comprobarValidez(entitatResum)
            QApplication.processEvents()
            QgsProject.instance().addMapLayer(entitatResum, False)

            if indicador == "FinquesAnyConstruccio":
                if self.dlg.mitjanaRadioButton.isChecked():
                    vlayer_resultat = self.Agregacio(entitatResum, vlayer.id(), "intersects", "SupCons", 6, "sum",
                                                     indicador, "first_value")
                    vlayer_resultat = self.MediaPonderada(vlayer_resultat)
                else:
                    vlayer_resultat = self.Agregacio(vlayer, entitatResum.id(), "intersects", "id", 4, "concatenate",
                                                     "modaPonderada", "first_value")
                    self.progress_changed(70)
                    QApplication.processEvents()

                    vlayer_resultat.startEditing()
                    features = vlayer_resultat.getFeatures()
                    for feature in features:
                        if (feature.attribute("SupCons") == None) or feature.attribute("Any_constr") == None:
                            vlayer_resultat.deleteFeature(feature.id())
                    vlayer_resultat.commitChanges()

                    vlayer_calculat = self.procesoModaPonderada(vlayer_resultat)

                    QgsProject.instance().addMapLayer(vlayer_calculat, False)

                    vlayer_resultat = self.Agregacio(entitatResum, vlayer_calculat.id(), "intersects", "SupCons", 6, "sum",
                                                     "modaPonderada2", "first_value")
                    QgsProject.instance().removeMapLayers([vlayer_calculat.id()])
            else:
                vlayer_resultat = self.Agregacio(entitatResum, vlayer.id(), "intersects", "SupCons", 6, "sum", indicador, "first_value")

            QApplication.processEvents()
            QgsProject.instance().removeMapLayers([entitatResum.id()])

        '''Transformación del vlayer_resultat a Shape para poder editarlo'''
        if vlayer_resultat.isValid():
            self.progress_changed(90)
            QApplication.processEvents()
            Area = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
            """Es crea un Shape a la carpeta temporal amb la data i hora actual"""
            if (qgis.utils.Qgis.QGIS_VERSION_INT >= 31000):
                save_options = QgsVectorFileWriter.SaveVectorOptions()
                save_options.driverName = "ESRI Shapefile"
                save_options.fileEncoding = "UTF-8"
                transform_context = QgsProject.instance().transformContext()
                error = QgsVectorFileWriter.writeAsVectorFormatV2(vlayer_resultat,
                                                                  TEMPORARY_PATH + "/Area_" + Area + ".shp",
                                                                  transform_context, save_options)
            else:
                error = QgsVectorFileWriter.writeAsVectorFormat(vlayer_resultat,
                                                                TEMPORARY_PATH + "/Area_" + Area + ".shp",
                                                                "utf-8", vlayer_resultat.crs(), "ESRI Shapefile")
            vlayer_resultat = None
            """Es carrega el Shape a l'entorn del QGIS"""
            vlayer_resultat = QgsVectorLayer(TEMPORARY_PATH + "/Area_" + Area + ".shp", capa, "ogr")

        if self.dlg.tabWidget.currentIndex() == 0:
            self.progress_changed(95)
            vlayer_resultat.startEditing()
            vlayer_resultat.addAttribute(QgsField('Indicador', QVariant.Double))
            vlayer_resultat.commitChanges()
            vlayer_resultat.updateFields()

            '''Cálculo del Indicador'''
            vlayer_resultat.startEditing()
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "Indicador")
            supConsTotal = 0
            unitatTotal = 0
            for feature in features:
                if (feature.attribute("SupCons") == None):
                    vlayer_resultat.deleteFeature(feature.id())
                    continue

                if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge':
                    unitat = int(feature.attribute("Habitants"))
                else:
                    unitat = float(feature.geometry().area())

                supCons = feature.attribute("SupCons")
                if type(supCons) is QVariant:
                    supCons = supCons.Double
                else:
                    supCons = float(supCons)
                if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatPlanta0Area' and supCons > float(feature.geometry().area()):
                    supCons = float(feature.geometry().area())

                inverse = self.dlg.inverse_ratio.isChecked()
                if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge':
                    inverse = not inverse

                if not inverse:
                    if unitat == 0:
                        value = 0
                    else:
                        value = supCons / unitat
                else:
                    if supCons == 0:
                        value = 0
                    else:
                        value = unitat / supCons
                supConsTotal += supCons
                unitatTotal += unitat
                vlayer_resultat.changeAttributeValue(feature.id(), index, value)

            '''MEDIA'''
            if self.dlg.checkbox_media.isChecked() and self.dlg.tabWidget.currentIndex() == 0:
                if not self.dlg.inverse_ratio.isChecked():
                    if unitatTotal == 0:
                        media = 0
                    else:
                        media = supConsTotal / unitatTotal
                else:
                    if supConsTotal == 0:
                        media = 0
                    else:
                        media = unitatTotal / supConsTotal
                if media != 0:
                    for feature in vlayer_resultat.getFeatures():
                        vlayer_resultat.changeAttributeValue(feature.id(), index,
                                                             feature.attribute("Indicador") / media * 100)

            vlayer_resultat.commitChanges()

        if indicador == "FinquesAnyConstruccio":
            vlayer_resultat.startEditing()
            if self.dlg.mitjanaRadioButton.isChecked():
                vlayer_resultat.deleteAttribute(self.getIndexField(vlayer_resultat, "SCxAC"))
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "Any_constr")
            for feature in features:
                if (feature.attribute("SupCons") == None) or feature.attribute("Any_constr") == None:
                    vlayer_resultat.deleteFeature(feature.id())
                vlayer_resultat.changeAttributeValue(feature.id(), index, str(feature.attribute("Any_constr"))[:4])
            vlayer_resultat.commitChanges()

        if self.dlg.tabWidget.currentIndex() == 2:
            vlayer_resultat.startEditing()
            features = vlayer_resultat.getFeatures()
            for feature in features:
                if feature.attribute("Pis") == "OD":
                    index = self.getIndexField(vlayer_resultat, "Indicador")
                    value = int(feature.attribute("SupCons")/float(feature.geometry().area())) + 1
                    vlayer_resultat.changeAttributeValue(feature.id(), index, value)
            vlayer_resultat.commitChanges()

        if self.getUnitats() == "hab/m^2 x 10000":
            vlayer_resultat.startEditing()
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "Indicador")
            for feature in features:
                value = float(feature.attribute("Indicador")) * 10000
                vlayer_resultat.changeAttributeValue(feature.id(), index, value)
            vlayer_resultat.commitChanges()

        self.mostraSHPperPantalla(vlayer_resultat, capa +" "+self.getUnitats())
        QgsProject.instance().removeMapLayers([vlayer.id()])

        QApplication.processEvents()
        iface.mapCanvas().refresh()
        drop = ''
        drop += 'DROP TABLE IF EXISTS "tr_temp' + Fitxer + '";\n'
        drop += 'DROP TABLE IF EXISTS "LayerExportat' + Fitxer + '";\n'
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
            print("Error DROP final")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            QMessageBox.information(None, "Error", "Error DROP final")
            conn.rollback()
            self.progress_changed(0)
            self.dlg.setEnabled(True)
            self.barraEstat_connectat()
        self.progress_changed(100)
        self.barraEstat_connectat()
        self.dlg.setEnabled(True)


    # Processing feedback
    def progress_changed(self, progress):
        self.dlg.progressBar.setValue(progress)


    def Agregacio(self, Entitat_Resum, Entitat_Detall, operacion, camp, tipus, operacio_aggregate,indicador, aggregate):
        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida='memory:'
        else:
            sortida='TEMPORARY_OUTPUT'
        alg = {
            'FIELD_LENGTH': 80,
            'FIELD_NAME': 'UUID',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': 'uuid()',
            'INPUT': Entitat_Resum,
            'NEW_FIELD': True,
            'OUTPUT': sortida
        }
        ILLES_UNIQUE = processing.run('qgis:fieldcalculator', alg)  # , feedback=f)

        operador = operacio_aggregate
        if indicador == 'DensitatHabitantsHabitatge':
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                               {'aggregate': 'first_value',
                                'delimiter': ',',
                                'input': 'aggregate( \'' + Entitat_Detall + '\', \'sum\',\"Habitants\", intersects( $geometry , geometry( @parent)))',
                                'length': 0,
                                'name': 'Habitants',
                                'precision': 0,
                                'type': 2}],
                'OUTPUT': sortida
            }
        elif indicador=="FinquesAnyConstruccio":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                                {'aggregate': 'first_value',
                                 'delimiter': ',',
                                 'input': 'aggregate( \'' + Entitat_Detall + '\', \'sum\',\"SCxAC\", intersects( $geometry , geometry( @parent)))',
                                 'length': 0,
                                 'name': 'SCxAC',
                                 'precision': 0,
                                 'type': 2}],
                'OUTPUT': sortida
            }
        elif indicador == "modaPonderada":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_string(\"' + camp + '\"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': 0,
                                'name': camp + "_agrupat",
                                'precision': 0,
                                'type': tipus
                                }],
                'OUTPUT': sortida
            }
            camp = camp + "_agrupat"
        elif indicador=="modaPonderada2":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:="' + camp + '", filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                                {'aggregate': 'first_value',
                                 'delimiter': ',',
                                 'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'max\',expression:=\"Any\", filter:=intersects( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                 'length': 0,
                                 'name': 'Any_constr',
                                 'precision': 0,
                                 'type': 2}],
                'OUTPUT': sortida
            }
        else:
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                }],
                'OUTPUT': sortida
            }

        pep = processing.run('qgis:aggregate', alg_params, feedback=f)

        if indicador == 'DensitatHabitantsHabitatge':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "Habitants"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        elif indicador == 'FinquesAnyConstruccio':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "SCxAC"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        elif indicador == 'modaPonderada2':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "Any_constr"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        else:
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        pep2 = processing.run('native:joinattributestable', alg)  # , feedback=f)

        alg = {
            'INPUT': pep2['OUTPUT'],
            'COLUMN': 'UUID',
            'OUTPUT': sortida
        }

        pep3 = processing.run('qgis:deletecolumn', alg)  # , feedback=f)
        return pep3['OUTPUT']

    def barraEstat_processant(self):
        '''Aquesta funció canvia l'aparença de la barra inferior a "Processant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: rgb(255, 125, 155)')
        self.dlg.lblEstatConn.setText("Processant...")
        QApplication.processEvents()

    def barraEstat_noConnectat(self):
        '''Aquesta funció canvia l'aparença de la barra inferior a "No connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
        self.dlg.lblEstatConn.setText('No connectat')
        QApplication.processEvents()

    def barraEstat_connectat(self):
        '''Aquesta funció canvia l'aparença de la barra inferior a "Connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
        self.dlg.lblEstatConn.setText('Connectat')
        QApplication.processEvents()

    def barraEstat_connectant(self):
        '''Aquesta funció canvia l'aparença de la barra inferior a "Connectant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ffff7f')
        self.dlg.lblEstatConn.setText('Connectant...')
        QApplication.processEvents()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        '''for action in self.actions:
            self.iface.removePluginMenu(
                self.tr('&exemple'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar'''
        for action in self.actions:
            self.iface.removePluginMenu('&CCU', action)
            self.toolbar.removeAction(action)

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.estatInicial()
        self.dlg.show()
        conn = self.getConnections()
        # Run the dialog event loop
        self.populateComboBox(self.dlg.comboConnexio, conn, 'Selecciona connexió', True)
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass


