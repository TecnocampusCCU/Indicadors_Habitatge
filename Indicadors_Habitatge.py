# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Indicadors_Habitatge
                                 A QGIS plugin
 Indicadors_Habitatge
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-01
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Josep LÃ³pez
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys
import os
import processing
from os.path import expanduser
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import QAction, QMessageBox, QTableWidgetItem, QApplication, QToolBar, QColorDialog, QFileDialog
from qgis.core import QgsMapLayer
from qgis.core import QgsDataSourceUri
from qgis.core import QgsVectorLayer
from qgis.core import QgsFeatureRequest
from qgis.core import QgsField
from qgis.core import QgsPoint
from qgis.core import QgsPointXY
from qgis.core import QgsFeatureRenderer
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsGradientColorRamp
from qgis.core import QgsProject
from qgis.core import QgsRendererRange
from qgis.core import QgsSymbol
from qgis.core import QgsFillSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsSymbolLayerRegistry
from qgis.core import QgsRandomColorRamp
from qgis.core import QgsRendererRangeLabelFormat
from qgis.core import QgsProject
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsRenderContext
from qgis.core import QgsPalLayerSettings
from qgis.core import QgsTextFormat
from qgis.core import QgsTextBufferSettings
from qgis.core import QgsVectorLayerSimpleLabeling
from qgis.core import QgsWkbTypes
from qgis.core import QgsVectorLayerExporter
from qgis.core import QgsProcessingFeedback
from qgis.core import QgsFeature
from qgis.core import Qgis
import psycopg2
import unicodedata
import datetime
import time
import qgis.utils
from qgis.utils import iface
from PyQt5.QtSql import *
import datetime
import time

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Indicadors_Habitatge_dialog import Indicadors_HabitatgeDialog
import os.path
from itertools import dropwhile

"""
Variables globals per a la connexio
i per guardar el color dels botons
"""
Versio_modul = "V_Q3.240611"
nomBD1 = ""
contra1 = ""
host1 = ""
port1 = ""
usuari1 = ""
schema = ""
Fitxer = ""
versio_db = ""
cur = None
conn = None
Path_Inicial = expanduser("~")
#Llista_Metodes = ["ILLES", "PARCELES", "SECCIONS", "BARRIS", "DISTRICTES POSTALS", "DISTRICTES INE", "SECTORS"]
Llista_Metodes = ["ILLES", "PARCELES", "SECCIONS", "BARRIS", "DISTRICTES POSTALS", "DISTRICTES INE"]
#Llista_Camps_Metodes = ["ILLES", "parcel", "Seccions", "Barris", "DistrictesPostals", "Districtes", "Sectors"]
Llista_Camps_Metodes = ["zone", "parcel_temp", "seccions", "barris", "districtes_postals", "districtes"]

class Indicadors_Habitatge:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Indicadors_Habitatge_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = Indicadors_HabitatgeDialog()

        self.dlg.bt_sortir.clicked.connect(self.on_click_Sortir)
        self.dlg.bt_inici.clicked.connect(self.on_click_Inici)
        self.dlg.comboConnexio.currentIndexChanged.connect(self.on_Change_ComboConn)
        self.dlg.color.clicked.connect(self.on_click_Color)
        self.dlg.colorTag.clicked.connect(self.on_click_ColorEtiqueta)
        self.dlg.CB_etiquetes.stateChanged.connect(self.on_checkAddTags)
        self.dlg.RB_color.toggled.connect(self.on_checkRB_color)
        self.dlg.RB_degradat.toggled.connect(self.on_checkRB_degradat)
        self.dlg.Transparencia.valueChanged.connect(self.on_valuechange_Transparencia)
        self.dlg.tabWidget.currentChanged.connect(self.on_currentchange_tab)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr('&CCU')
        # TODO: We are going to let the user set this up in a future iteration
        # self.toolbar = self.iface.addToolBar('CCU')
        # self.toolbar.setObjectName('Indicadors_Habitatge')

        trobat = False
        for x in iface.mainWindow().findChildren(QToolBar, 'CCU'):
            self.toolbar = x
            trobat = True

        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Indicadors_Habitatge', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Indicadors_Habitatge/icon.png'
        self.add_action(
            icon_path,
            text=self.tr('Indicadors_Habitatge'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def on_click_Sortir(self):
        '''
        Tanca la finestra del plugin 
        '''
        self.estatInicial()
        self.dlg.close()

    def getConnections(self):
        """Aquesta funcio retorna les connexions que estan guardades en el projecte."""
        s = QSettings()
        s.beginGroup("PostgreSQL/connections")
        currentConnections = s.childGroups()
        s.endGroup()
        return currentConnections

    def populateComboBox(self, combo, list, predef, sort):
        """Procediment per omplir el combo especificat amb la llista suministrada"""
        combo.blockSignals(True)
        combo.clear()
        model = QStandardItemModel(combo)
        predefInList = None
        for elem in list:
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        if sort:
            model.sort(0)
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0, predef)
                combo.setCurrentIndex(0)
        combo.blockSignals(False)

    def setButtonChecked(self, boto):
        '''
        FunciÃ³ auxiliar per canviar aparenÃ§a de botons
        '''
        boto.setChecked(True)
        boto.setStyleSheet('background-color: rgb(85, 255, 127)')

    def setButtonUnchecked(self, boto):
        '''
        FunciÃ³ auxiliar per canviar aparenÃ§a de botons
        '''
        boto.setChecked(False)
        boto.setStyleSheet('background-color: rgb(255, 156, 156)')

    def on_currentchange_tab(self):
        if self.dlg.tabWidget.currentIndex() == 2:
            self.dlg.Metodes.setEnabled(False)
        else:
            self.dlg.Metodes.setEnabled(True)

    def on_Change_ComboConn(self):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de les connexions,
        automÃ ticament comprova si es pot establir
        connexiÃ³ amb la bbdd seleccionada.
        """
        global aux
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global schema
        global cur
        global conn
        global Llista_Metodes
        global Llista_Camps_Metodes

        s = QSettings()
        select = 'Selecciona connexiÃ³'
        nom_conn = self.dlg.comboConnexio.currentText()

        if nom_conn != select:
            aux = True
            s.beginGroup("PostgreSQL/connections/" + nom_conn)
            currentKeys = s.childKeys()

            nomBD1 = s.value("database", "")
            contra1 = s.value("password", "")
            host1 = s.value("host", "")
            port1 = s.value("port", "")
            usuari1 = s.value("username", "")
            schema = 'public'

            self.barraEstat_connectant()
            self.dlg.lblEstatConn.setAutoFillBackground(True)
            QApplication.processEvents()

            # Connexio
            nomBD = nomBD1.encode('ascii', 'ignore')
            usuari = usuari1.encode('ascii', 'ignore')
            servidor = host1.encode('ascii', 'ignore')
            contrasenya = contra1.encode('ascii', 'ignore')
            try:
                estructura = "dbname='" + nomBD.decode("utf-8") + "' user='" + usuari.decode(
                    "utf-8") + "' host='" + servidor.decode("utf-8") + "' password='" + contrasenya.decode(
                    "utf-8") + "'"  # schema='"+schema+"'"
                conn = psycopg2.connect(estructura)
                self.barraEstat_connectat()
                cur = conn.cursor()

                try:
                    self.detect_database_version()
                except Exception as ex:
                    print("No s'ha pogut detectar la versio de la BBDD")
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print(message)
                    QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                    conn.rollback()
                    self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                    self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                    return
            except Exception as ex:
                print("I am unable to connect to the database")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print(message)
                QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                conn.rollback()
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return

            Metodes, tooltips = self.Comprova_Metodes(Llista_Metodes, Llista_Camps_Metodes, cur)
            self.populateComboBox_tooltip(self.dlg.Cmb_Metode, Metodes, tooltips, 'Selecciona MÃ¨tode', True)


        else:
            aux = False
            self.barraEstat_noConnectat()

    def detect_database_version(self):
        global cur
        global conn
        global versio_db
        sql = "select taula from config where variable = 'versio';"
        cur.execute(sql)
        versio_db = cur.fetchone()[0]
        print("VersiÃ³ de la base de dades: " + versio_db)

        if versio_db == '1.0':
            try:
                cur.execute(f"""
                            DROP TABLE IF EXISTS "parcel_temp";
                            CREATE TABLE "parcel_temp" (
                                id_parcel,
                                geom,
                                cadastral_reference
                            ) AS SELECT "id", "geom", "utm_total" FROM parcel;
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS "zone";
                            CREATE LOCAL TEMP TABLE "zone" (
                                id_zone,
                                geom,
                                cadastral_zoning_reference
                            ) AS SELECT "id", "geom", "D_S_I" FROM "ILLES";
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS "address";
                            CREATE LOCAL TEMP TABLE "address" (
                                id_address,
                                geom,
                                cadastral_reference,
                                designator
                            ) AS SELECT "id", "geom", "REF_CADAST", "Carrer_Num_Bis" FROM "dintreilla";
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS "building";
                            CREATE LOCAL TEMP TABLE "building" (
                                id_building,
                                cadastral_reference,
                                current_use
                            ) AS SELECT "id", "Ref_Cadastral", "Us" FROM "FinquesUS";
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS "building_floor";
                            CREATE LOCAL TEMP TABLE "building_floor" (
                                id_floor,
                                cadastral_reference,
                                stairs,
                                floor,
                                built_surface
                            ) AS SELECT "id", "Ref_Cadastral", "Escala", "Pis", "Superficie_cons" FROM "FinquesPlantes";
                            """)
                conn.commit()
            except Exception as ex:
                print("Error creant taules temporals per a la versiÃ³ 1.0")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print(message)
                QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                conn.rollback()
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return
        elif versio_db == '2.0':
            try:
                cur.execute(f"""
                            DROP TABLE IF EXISTS "parcel_temp";
                            CREATE TABLE "parcel_temp" AS SELECT * FROM parcel;
                            """)
                conn.commit()
            except Exception as ex:
                print("Error creant taules temporals per a la versiÃ³ 2.0")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print(message)
                QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                conn.rollback()
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return
        else:
                raise Exception("VersiÃ³ de la base de dades no reconeguda")

    def Comprova_Metodes(self, llista_noms, llista_camps, cur):
        resultat = []

        resultat_tooltip = []
        for index, item in enumerate(llista_camps):
            sql = "select table_name from information_schema.tables where table_name in ('" + item + "') and table_schema ='public'"
            cur.execute(sql)
            rows = cur.fetchall()
            if len(rows) > 0:
                resultat.append(llista_noms[index])
                resultat_tooltip.append(llista_camps[index])
        return resultat, resultat_tooltip

    def populateComboBox_tooltip(self, combo, list, tooltip, predef, sort):
        '''
        procedure to fill specified combobox with provided list
        '''
        combo.blockSignals(True)
        combo.clear()
        model = QStandardItemModel(combo)
        predefInList = None
        for index, elem in enumerate(list):
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            item.setToolTip(tooltip[index])
            model.appendRow(item)
            if elem == predef:
                predefInList = elem

        if sort:
            model.sort(0)
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0, predef)
                combo.setCurrentIndex(0)
        combo.blockSignals(False)

    def ompleCombos(self, combo, llista, predef):
        """Aquesta funciÃ³ omple els combos que li passem per parÃ metres"""
        combo.blockSignals(True)
        combo.clear()
        model = QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                if isinstance(elem, tuple):
                    item = QStandardItem(str(elem[0]))
                else:
                    item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem[0]))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0, predef)
                combo.setCurrentIndex(0)
        combo.blockSignals(False)

    def estatInicial(self):
        '''
        @param self:
        Resteja tots els valors per defecte del plugin: estat inicial.
        '''
        global micolor
        global micolorTag
        global aux
        global Versio_modul
        global itemSel
        global lbl_Cost
        aux = False
        itemSel = None
        self.barraEstat_noConnectat()
        self.dlg.versio.setText(Versio_modul)
        self.dlg.Cmb_Metode.setCurrentIndex(0)
        self.dlg.tabWidget.setCurrentIndex(0)
        self.dlg.RB_color.setChecked(True)
        self.dlg.inverse_ratio.setChecked(False)
        self.dlg.checkbox_media.setChecked(False)
        self.dlg.color.setEnabled(True)
        self.dlg.Transparencia.setEnabled(True)
        self.dlg.comboIndicador.clear
        self.dlg.comboIndicador_2.clear
        self.dlg.comboIndicador_3.clear
        self.dlg.CB_etiquetes.setChecked(False)
        self.dlg.mitjanaRadioButton.setChecked(True)
        self.dlg.mida.setEnabled(False)
        self.dlg.colorTag.setEnabled(False)
        self.dlg.decimals.setEnabled(False)
        self.dlg.min.setEnabled(False)
        self.dlg.max.setEnabled(False)
        self.dlg.Transparencia.setEnabled(True)
        self.dlg.Transparencia_lbl.setText(str(self.dlg.Transparencia.value()) + ' %')
        micolor = QColor(255, 0, 0, 255)
        micolorTag = QColor(128, 0, 128, 255)
        self.dlg.color.setStyleSheet('border:1px solid #000000; background-color: #ff0000')
        self.dlg.colorTag.setStyleSheet('border:1px solid #000000; background-color: #800080')
        self.dlg.min.setValue(500.00)
        self.dlg.max.setValue(50000.00)
        self.progress_changed(0)
        self.dlg.Metodes.setEnabled(True)
        llista = ['DensitatHabitantsHabitatge', 'DensitatHabitatgeÃrea',
                  'DensitatEdificis', 'DensitatPlanta0Area']
        self.ompleCombos(self.dlg.comboIndicador, llista, "Selecciona un indicador")
        llista = ['FinquesAnyConstruccio']
        self.ompleCombos(self.dlg.comboIndicador_2, llista, "Selecciona un indicador")
        llista = ['MapaAlÃ§adesParcelÂ·la']
        self.ompleCombos(self.dlg.comboIndicador_3, llista, "Selecciona un indicador")
        self.SetTooltipIndicadors()

    def SetTooltipIndicadors(self):
        self.dlg.comboIndicador.setItemData(1, "Sup. construÃ¯da amb Ãºs d'habitatge/nombre d'habitants",
                                            QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(2, "Sup. construÃ¯da amb Ãºs d'habitatge/Sup. geomÃ¨trica (solar)",
                                            QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(3, "Sup. construÃ¯da per a qualsevol Ãºs/Sup. geometrica (solar)",
                                            QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador.setItemData(4, "Sup. construÃ¯da en planta baixa/Sup. geomÃ¨trica (solar)",
                                            QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador_2.setItemData(1, "Any construcciÃ³", QtCore.Qt.ToolTipRole)
        self.dlg.comboIndicador_3.setItemData(1, "Nombre de plantes edifici mes alt de la parcelÂ·la",
                                            QtCore.Qt.ToolTipRole)

    def on_checkRB_color(self, enabled):
        if enabled:
            self.dlg.color.setEnabled(True)
            self.dlg.Transparencia.setEnabled(True)
        else:
            self.dlg.color.setEnabled(False)
            self.dlg.Transparencia.setEnabled(True)

    def on_checkAddTags(self, state):
        '''Aquesta funcio habilita o deshabilitat els diferents elements de les etiquetes'''
        if state != QtCore.Qt.Checked:
            self.dlg.mida.setEnabled(False)
            self.dlg.colorTag.setEnabled(False)
            self.dlg.decimals.setEnabled(False)
            self.dlg.min.setEnabled(False)
            self.dlg.max.setEnabled(False)
        else:
            self.dlg.mida.setEnabled(True)
            self.dlg.colorTag.setEnabled(True)
            self.dlg.decimals.setEnabled(True)
            self.dlg.min.setEnabled(True)
            self.dlg.max.setEnabled(True)

    def on_click_ColorEtiqueta(self):
        """Aquesta funciÃ³ obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolorTag
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorTag = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolorTag.name()
        self.dlg.colorTag.setStyleSheet(estilo)
        self.dlg.colorTag.setAutoFillBackground(True)
        pep = self.dlg.colorTag.palette().color(1)
        pass

    def on_checkRB_degradat(self, enabled):
        if enabled:
            self.dlg.ColorDegradat.setEnabled(True)
            self.dlg.LE_rang.setEnabled(True)
            self.dlg.combo_Tipus.setEnabled(True)
        else:
            self.dlg.ColorDegradat.setEnabled(False)
            self.dlg.LE_rang.setEnabled(False)
            self.dlg.combo_Tipus.setEnabled(False)

    def on_valuechange_Transparencia(self):
        """Aquesta es una funcio auxiliar que canvia el valor de la etiqueta associada a la transperencia de la capa escollida"""
        self.dlg.Transparencia_lbl.setText(str(self.dlg.Transparencia.value()) + ' %')

    def on_click_ColorEtiqueta(self):
        """Aquesta funciÃ³ obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolorTag
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolorTag = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolorTag.name()
        self.dlg.colorTag.setStyleSheet(estilo)
        self.dlg.colorTag.setAutoFillBackground(True)
        pep = self.dlg.colorTag.palette().color(1)
        pass

    def on_click_Color(self):
        """Aquesta funciÃ³ obra un dialeg per poder triar el color del contorn de l'area que volem pintar. """
        global micolor
        aux = QColorDialog.getColor()
        if aux.isValid():
            micolor = aux
        estilo = 'border:1px solid #000000; background-color: ' + micolor.name()
        self.dlg.color.setStyleSheet(estilo)
        self.dlg.color.setAutoFillBackground(True)
        pep = self.dlg.color.palette().color(1)
        pass

    def controlErrorsInput(self):
        '''
        Aquesta funciÃ³ s'encarrega de controlar que quan comenci el cÃ lcul
        totes les entrades de dades estiguin omplertes i siguin correctes
        '''
        global itemSel
        errors = []

        if self.dlg.comboConnexio.currentText() == 'Selecciona connexiÃ³':
            errors.append("No hi ha connexiÃ³")
        if self.dlg.tabWidget.currentIndex() == 0:
            if self.dlg.Cmb_Metode.currentText() == 'Selecciona MÃ¨tode' or self.dlg.Cmb_Metode.currentText() == '':
                errors.append("No hi ha mÃ¨tode de treball")
            if self.dlg.comboIndicador.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")

        elif self.dlg.tabWidget.currentIndex() == 1:
            if self.dlg.Cmb_Metode.currentText() == 'Selecciona MÃ¨tode' or self.dlg.Cmb_Metode.currentText() == '':
                errors.append("No hi ha mÃ¨tode de treball")
            if self.dlg.comboIndicador_2.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")
        else:
            if self.dlg.comboIndicador_3.currentText() == 'Selecciona un indicador' or self.dlg.comboIndicador.currentText() == '':
                errors.append("No hi ha indicador")
        return errors

    def getIndicador(self, fitxer):
        currentComboText = self.dlg.comboIndicador.currentText()
        if currentComboText == 'DensitatHabitantsHabitatge':
            return  f'''
                    SELECT DISTINCT ON (parcel_temp.id_parcel)
                        parcel_temp.id_parcel,
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        building_floor.built_surface AS "SupCons",
                        tr."Habitants"
                    FROM
                        parcel_temp
                        LEFT JOIN tr_temp{fitxer} AS tr 
                            ON parcel_temp.cadastral_reference = tr."Parcela" AND tr."Habitants" IS NOT NULL
                        LEFT JOIN building_floor 
                        ON parcel_temp.cadastral_reference = building_floor.cadastral_reference AND building_floor.built_surface IS NOT NULL
                    WHERE
                        building_floor.built_surface IS NOT NULL
                    '''
        elif currentComboText == 'DensitatHabitatgeÃrea':
            # TODO: Revisar que les JOIN estiguin ben fetes, la JOIN de la building_floor abans no hi era perÃ² ara Ã©s necessari perquÃ¨ els camps de les taules han canviat
            return  f'''
                    SELECT DISTINCT ON (parcel_temp.id_parcel)
                        parcel_temp.id_parcel,
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        building_floor.built_surface AS "SupCons",
                        ST_Area(parcel_temp.geom)
                    FROM
                        parcel_temp
                        LEFT JOIN (
                            SELECT *
                            FROM building
                            WHERE current_use LIKE '1_residential'
                        ) AS edif
                            ON parcel_temp.cadastral_reference = edif.cadastral_reference
                        LEFT JOIN building_floor
                            ON building_floor.cadastral_reference = edif.cadastral_reference
                                AND building_floor.built_surface IS NOT NULL
                    WHERE
                        building_floor.built_surface IS NOT NULL
                    '''
        elif currentComboText == 'DensitatEdificis':
            return f'''
                    SELECT
                        ROW_NUMBER() OVER (
                            ORDER BY parcel_temp.cadastral_reference
                        ) AS "id_parcel",
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        SUM(building_floor.built_surface::INTEGER) AS "SupCons"
                    FROM
                        parcel_temp
                        LEFT JOIN building_floor
                            ON parcel_temp.cadastral_reference = building_floor.cadastral_reference
                    WHERE
                        building_floor.built_surface IS NOT NULL
                    GROUP BY
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference
                    '''
        elif currentComboText == 'DensitatPlanta0Area':
            return f'''
                    SELECT
                        ROW_NUMBER() OVER (
                            ORDER BY parcel_temp.cadastral_reference
                        ) AS "id_parcel",
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        SUM(building_floor.built_surface::INTEGER) AS "SupCons",
                        building_floor.floor
                    FROM
                        parcel_temp
                        LEFT JOIN (
                            SELECT *
                            FROM building_floor
                            WHERE floor IN ('0', '00', 'BX', 'BJ', 'OD', '0P', '0A')
                                OR (floor LIKE 'UE' AND stairs LIKE 'S')
                        ) AS building_floor
                        ON parcel_temp.cadastral_reference = building_floor.cadastral_reference
                    WHERE
                        building_floor.built_surface IS NOT NULL AND building_floor.built_surface != 0
                    GROUP BY
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        building_floor.floor
                    '''


    def getIndicador2(self):
        currentComboText = self.dlg.comboIndicador_2.currentText()
        if currentComboText == 'FinquesAnyConstruccio':
            # TODO: Revisar que l'SQL estigui bÃ© perquÃ¨ ja no tenim la taula FinquesAnyConstrucciÃ³, ara l'any es troba en format de Date a la taula building
            return f'''
                    SELECT
                        ROW_NUMBER() OVER (
                            ORDER BY parcel_temp.cadastral_reference
                        ) AS "id_parcel",
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        SUM(building_floor.built_surface::INTEGER) AS "SupCons",
                        b_year.date_of_construction,
                        (SUM(building_floor.built_surface::INTEGER) * b_year.date_of_construction) AS "SCxAC"
                    FROM
                        parcel_temp
                        LEFT JOIN building_floor
                            ON parcel_temp.cadastral_reference = building_floor.cadastral_reference
                        LEFT JOIN (
                            SELECT cadastral_reference, MAX(EXTRACT(YEAR FROM date_of_construction)::INTEGER)::INTEGER AS date_of_construction
                            FROM building
                            WHERE EXTRACT(YEAR FROM date_of_construction) BETWEEN {str(int(self.dlg.any_inici.value()))} AND {str(int(self.dlg.any_fi.value()))}
                            GROUP BY cadastral_reference
                        ) AS b_year
                            ON parcel_temp.cadastral_reference = b_year.cadastral_reference
                    WHERE
                        building_floor.built_surface IS NOT NULL AND b_year.date_of_construction IS NOT NULL
                    GROUP BY
                        parcel_temp.geom,
                        parcel_temp.cadastral_reference,
                        b_year.date_of_construction
                    '''

    def getIndicador3(self):
        currentComboText = self.dlg.comboIndicador_3.currentText()
        if currentComboText == 'MapaAlÃ§adesParcelÂ·la':
            return f'''
                    SELECT
                        DISTINCT m.*
                    FROM
                        mapa_alcades{Fitxer} AS m
                        INNER JOIN (
                            SELECT
                                MAX("Indicador") AS "Indicador",
                                cadastral_reference
                            FROM
                                mapa_alcades{Fitxer}
                            GROUP BY
                                cadastral_reference
                        ) max_table
                            ON m."Indicador" = max_table."Indicador"
                            AND m.cadastral_reference = max_table.cadastral_reference
                    '''

    def getTableAlcades(self):
        return f'''
                SELECT
                    m.*,
                    f.floor
                FROM
                    (
                        SELECT
                            ROW_NUMBER() OVER (
                                ORDER BY parcel_temp.id_parcel
                            ) AS "id_parcel",
                            parcel_temp.geom,
                            parcel_temp.cadastral_reference,
                            (
                                CASE
                                    WHEN alt."Indicador" != -1 THEN
                                        alt."Indicador"
                                    ELSE ( ("SupCons"::INTEGER) / ST_Area("geom")::INTEGER ) + 1
                                END
                            ) AS "Indicador",
                            alt."SupCons"
                        FROM
                            parcel_temp
                            LEFT JOIN (
                                SELECT
                                    cadastral_reference,
                                    MAX(
                                        CASE
                                            WHEN floor ~ '^[0-9\.]+$' THEN
                                                CAST(floor AS INTEGER) + 1
                                            ELSE
                                                (
                                                    CASE
                                                        WHEN floor LIKE 'OD' THEN
                                                            -1
                                                        ELSE
                                                            1
                                                    END
                                                )
                                        END
                                    ) AS "Indicador",
                                    (built_surface::INTEGER) AS "SupCons"
                                FROM
                                    building_floor
                                WHERE
                                    floor ~ '^[0-9\.]+$'
                                    OR floor IN ('0', '00', 'BX', 'BJ', 'OD', 'OP', 'OA')
                                    OR (floor LIKE 'UE' AND stairs LIKE 'S')
                                GROUP BY
                                    cadastral_reference,
                                    built_surface
                            ) AS alt
                                ON parcel_temp.cadastral_reference = alt.cadastral_reference
                        WHERE
                            alt."Indicador" IS NOT NULL
                            AND alt."SupCons" != 0
                    ) AS m
                    LEFT JOIN (
                        SELECT
                            cadastral_reference,
                            floor
                        FROM
                            building_floor
                        WHERE
                            floor LIKE 'AT'
                    ) AS f
                        ON m.cadastral_reference = f.cadastral_reference
                '''

    def getUnitats(self):
        if self.dlg.tabWidget.currentIndex() == 0:
            if (self.dlg.checkbox_media.isChecked()):
                return "%"
            currentComboText = self.dlg.comboIndicador.currentText()
        elif self.dlg.tabWidget.currentIndex() == 1:
            currentComboText = self.dlg.comboIndicador_2.currentText()
        else:
            currentComboText = self.dlg.comboIndicador_3.currentText()

        if currentComboText == 'DensitatHabitantsHabitatge':
            if not self.dlg.inverse_ratio.isChecked():
                return "hab/mÂ² x 10000"
            else:
                return "mÂ²/hab"
        elif currentComboText == 'DensitatHabitatgeÃrea':
            if not self.dlg.inverse_ratio.isChecked():
                return "mÂ²/mÂ²"
            else:
                return "mÂ²/mÂ²"
        elif currentComboText == 'DensitatEdificis':
            if not self.dlg.inverse_ratio.isChecked():
                return "mÂ²/mÂ²"
            else:
                return "mÂ²/mÂ²"
        elif currentComboText == 'DensitatPlanta0Area':
            if not self.dlg.inverse_ratio.isChecked():
                return "mÂ²/mÂ²"
            else:
                return "mÂ²/mÂ²"
        elif currentComboText == 'FinquesAnyConstruccio':
            return ""
        elif currentComboText == 'MapaAlÃ§adesParcelÂ·la':
            return ""
        return ""

    def mostraLayerPerPantalla(self, vlayer):
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global micolorTag
        try:
            if vlayer.isValid():
                crs = vlayer.dataProvider().sourceCrs()
                if self.dlg.tabWidget.currentIndex() != 2:
                    nomCapa = self.dlg.Cmb_Metode.currentText() + " " + self.getUnitats()
                else:
                    # TODO: Preguntar al Josep o al Miquel quÃ¨ hauria de posar al nom de la capa, abans sortia SelÂ·lecciona mÃ¨tode, per tant he escrit PARCELES com a placeholder
                    nomCapa = 'PARCELES'
                vlayer_temp = QgsVectorLayer(f"Polygon?crs={crs.authid()}", nomCapa, "memory")
                vlayer_temp.setCrs(crs)
                vlayer_temp.dataProvider().addAttributes(vlayer.dataProvider().fields())
                vlayer_temp.updateFields()
                vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())
                vlayer_temp.updateExtents()
                symbols = vlayer_temp.renderer().symbols(QgsRenderContext())
                symbol = symbols[0]
                if self.dlg.RB_color.isChecked():
                    symbol.setColor(self.dlg.color.palette().color(1))
                    vlayer.setOpacity(self.dlg.Transparencia.value() / 100)
                else:
                    if self.dlg.tabWidget.currentIndex() != 1:
                        fieldname = "Indicador"
                    else:
                        fieldname = "date_of_construction"
                    template = "%1 - %2 " + self.getUnitats()

                    numberOfClasses = int(float(self.dlg.LE_rang.value()))
                    mysymbol = QgsFillSymbol()
                    if (self.dlg.ColorDegradat.currentText() == 'Gris'):
                        colorRamp = QgsGradientColorRamp(QColor(230, 230, 230), QColor(60, 60, 60))
                    elif (self.dlg.ColorDegradat.currentText() == 'Vermell'):
                        colorRamp = QgsGradientColorRamp(QColor(255, 154, 154), QColor(154, 0, 0))
                    elif (self.dlg.ColorDegradat.currentText() == 'Groc'):
                        colorRamp = QgsGradientColorRamp(QColor(255, 255, 154), QColor(154, 154, 0))
                    elif (self.dlg.ColorDegradat.currentText() == 'Blau'):
                        colorRamp = QgsGradientColorRamp(QColor(154, 255, 255), QColor(0, 0, 154))
                    elif (self.dlg.ColorDegradat.currentText() == 'Verd'):
                        colorRamp = QgsGradientColorRamp(QColor(154, 255, 154), QColor(0, 154, 0))

                    format = QgsRendererRangeLabelFormat()

                    precision = 3
                    if self.dlg.tabWidget.currentIndex() == 1:
                        precision = 0
                    format.setFormat(template)
                    format.setPrecision(precision)
                    format.setTrimTrailingZeroes(False)
                    if (self.dlg.combo_Tipus.currentText() == 'Quantil'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer_temp, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Quantile,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Interval igual'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer_temp, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.EqualInterval,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Ruptures naturals'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer_temp, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Jenks, mysymbol,
                                                                             colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'DesviaciÃ³ estandard'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer_temp, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.StdDev,
                                                                             mysymbol, colorRamp)
                    elif (self.dlg.combo_Tipus.currentText() == 'Pretty breaks'):
                        renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer_temp, fieldname, numberOfClasses,
                                                                             QgsGraduatedSymbolRenderer.Pretty,
                                                                             mysymbol, colorRamp)
                    renderer.setLabelFormat(format, True)
                    vlayer_temp.setOpacity(self.dlg.Transparencia.value() / 100)
                    vlayer_temp.setRenderer(renderer)
                    QApplication.processEvents()

                if self.dlg.CB_etiquetes.isChecked():
                    layer_settings = QgsPalLayerSettings()
                    text_format = QgsTextFormat()

                    text_format.setFont(QFont("Arial", self.dlg.mida.value()))
                    text_format.setSize(self.dlg.mida.value())

                    text_format.setColor(QColor.fromRgb(micolorTag.red(), micolorTag.green(), micolorTag.blue()))
                    layer_settings.setFormat(text_format)

                    layer_settings.isExpression = True
                    if self.dlg.tabWidget.currentIndex() != 1:
                        layer_settings.fieldName = "to_string(round( \"Indicador\"," + str(
                            self.dlg.decimals.value()) + "))"
                    else:
                        # layer_settings.fieldName = "to_string(round( \"Any_constr\"," + str(
                        ### layer_settings.fieldName = "to_string(round( \"built_surface\"," + str(
                        layer_settings.fieldName = "to_string(round( \"date_of_construction\"," + str(
                            self.dlg.decimals.value()) + "))"
                    if self.dlg.checkbox_media.isChecked() and self.dlg.tabWidget.currentIndex() == 0:
                        layer_settings.fieldName += "+'%'"
                    QApplication.processEvents()

                    layer_settings.placement = QgsPalLayerSettings.AroundPoint
                    layer_settings.scaleVisibility = True
                    layer_settings.minimumScale = float(self.dlg.max.value())
                    layer_settings.maximumScale = float(self.dlg.min.value())
                    layer_settings.enabled = True

                    settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    vlayer_temp.setLabelsEnabled(True)
                    vlayer_temp.setLabeling(settings)
                    vlayer_temp.setScaleBasedVisibility(True)

                    vlayer_temp.triggerRepaint()

                QApplication.processEvents()
                QgsProject.instance().addMapLayer(vlayer_temp, False)
                root = QgsProject.instance().layerTreeRoot()
                myLayerNode = QgsLayerTreeLayer(vlayer_temp)
                root.insertChildNode(0, myLayerNode)
                myLayerNode.setCustomProperty("showFeatureCount", True)
                iface.mapCanvas().refresh()
            else:
                print("Error vector layer")
            QApplication.processEvents()
        except Exception as ex:
            print("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            self.progress_changed(0)
            self.dlg.setEnabled(True)
            self.barraEstat_connectat()
            QMessageBox.information(None, "Error",
                                    "Error mostrant el vlayer per pantalla.")

    def getIndexField(self, vlayer, fieldName):
        fields = vlayer.fields()
        for x in range(len(fields)):
            if (fields[x].displayName() == fieldName):
                return x
        return -1

    def comprobarValidez(self, vlayer):
        parameters = {'ERROR_OUTPUT': 'memory:',
                      'INPUT_LAYER': vlayer,
                      'INVALID_OUTPUT': 'memory:',
                      'METHOD': 2,
                      'VALID_OUTPUT': 'memory:'}

        result = processing.run('qgis:checkvalidity', parameters)

        return result['VALID_OUTPUT']

    def procesoModaPonderada(self, vlayer):
        f = QgsProcessingFeedback()
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida = 'memory:'
        else:
            sortida = 'TEMPORARY_OUTPUT'

        parameters = {'CATEGORIES_FIELD_NAME': ['date_of_construction', 'id_agrupat'],
                      'INPUT': vlayer,
                      'OUTPUT': sortida,
                      'VALUES_FIELD_NAME': 'SupCons'}
        result = processing.run('qgis:statisticsbycategories', parameters)
        print("Proceso moda ponderada 1")

        parameters = {
            'INPUT': result['OUTPUT'],
            'GROUP_BY': 'id_agrupat',
            'AGGREGATES': [{'aggregate': 'concatenate',
                            'delimiter': '',
                            'input': 'if(sum=maximum(sum,group_by:=id_agrupat),to_string(\"date_of_construction\"),\'\')',
                            'length': -1,
                            'name': 'Any',
                            'precision': -1,
                            'type': 10},
                           {'aggregate': 'first_value',
                            'delimiter': ',',
                            'input': '\"id_agrupat\"',
                            'length': 0,
                            'name': 'id_agrupat',
                            'precision': 0,
                            'type': 4}],
            'OUTPUT': sortida
        }
        result = processing.run('qgis:aggregate', parameters, feedback=f)
        print("Proceso moda ponderada 2")

        parameters = {
            'INPUT': vlayer,
            'INPUT_2': result['OUTPUT'],
            'DISCARD_NONMATCHING': False,
            'FIELD': 'id_agrupat',
            'FIELDS_TO_COPY': ['Any'],
            'FIELD_2': 'id_agrupat',
            'METHOD': 1,
            'PREFIX': '',
            'OUTPUT': sortida
        }
        result = processing.run('native:joinattributestable', parameters, feedback=f)
        print("Proceso moda ponderada 3")

        return result['OUTPUT']

    def MediaPonderada(self, vlayer):
        vlayer.startEditing()
        vlayer.addAttribute(QgsField('date_of_construction', QVariant.Int))
        vlayer.commitChanges()
        vlayer.updateFields()

        vlayer.startEditing()
        features = vlayer.getFeatures()
        index = self.getIndexField(vlayer, "date_of_construction")
        for feature in features:
            unitat = int(feature.attribute("SCxAC"))
            supCons = feature.attribute("SupCons")
            if type(supCons) is QVariant:
                supCons = supCons.Double
            else:
                supCons = float(supCons)

            if supCons == 0:
                value = 0
            else:
                value = unitat / supCons
            vlayer.changeAttributeValue(feature.id(), index, value)
        vlayer.commitChanges()
        return vlayer

    def on_click_Inici(self):
        '''
        FUNCIÃ DE CÃLCUL PRINCIPAL
        S'encarrega de fer el cÃ lcul de les N-entitats mÃ©s properes a l'adreÃ§a escollida per l'usuari
        i mostrar per pantalla, tan en el mapa com en el quadre del mÃ²dul, els diferents resultats.
        '''
        global cur
        global conn
        global itemSel
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1

        global lbl_Cost
        global Fitxer

        QApplication.processEvents()
        Fitxer = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
        self.progress_changed(0)

        '''Control d'errors'''
        llistaErrors = self.controlErrorsInput()
        if len(llistaErrors) > 0:
            llista = "Llista d'errors:\n\n"
            for i in range(0, len(llistaErrors)):
                llista += ("- " + llistaErrors[i] + '\n')
            QMessageBox.information(None, "Error", llista)
            self.dlg.setEnabled(True)
            return

        self.barraEstat_processant()

        self.dlg.setEnabled(False)
        uri = QgsDataSourceUri()
        try:
            uri.setConnection(host1, port1, nomBD1, usuari1, contra1)
        except Exception as ex:
            print("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.dlg.setEnabled(True)
            self.progress_changed(0)
            self.barraEstat_connectat()
            return

        QApplication.processEvents()
        self.progress_changed(5)

        try:
            self.detect_database_version()
        except Exception as ex:
            print("Error a la creacio taules temporals bd")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.dlg.setEnabled(True)
            self.progress_changed(0)
            self.barraEstat_connectat()
            return

        if self.dlg.tabWidget.currentIndex() == 0:
            sql = self.getIndicador(Fitxer)
            indicador = self.dlg.comboIndicador.currentText()
        elif self.dlg.tabWidget.currentIndex() == 1:
            sql = self.getIndicador2()
            indicador = self.dlg.comboIndicador_2.currentText()
        else:
            cur.execute(
                "DROP TABLE IF EXISTS mapa_alcades" + Fitxer + "")
            conn.commit()
            cur.execute(
                "CREATE TABLE mapa_alcades" + Fitxer + " AS " + self.getTableAlcades())
            conn.commit()
            sql = self.getIndicador3()
            indicador = self.dlg.comboIndicador_3.currentText()

        vlayer = None
        uri.setDataSource("","("+sql+")","geom","","id_parcel")

        if self.dlg.tabWidget.currentIndex() == 2:
            capa = "PARCELES"
        else:
            capa = self.dlg.Cmb_Metode.currentText()

        '''Buscar archivo de parcelas'''
        if self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge' and self.dlg.tabWidget.currentIndex() == 0:
            path = QFileDialog.getExistingDirectory(self.dlg,
                                                    "Busca la carpeta que contÃ© els arxius provinents del mÃ²dul TAULA RESUM",
                                                    Path_Inicial + "/",
                                                    QFileDialog.ShowDirsOnly)
            noTrobat = True
            while noTrobat:
                if (path != ''):
                    if versio_db == '1.0':
                        nom_path_parceles = path + "/tr_parceles_v1.csv"
                    else:
                        nom_path_parceles = path + "/tr_parceles_v2.csv"
                    if (os.path.exists(nom_path_parceles)):
                        noTrobat = False

                        arxiu = open(nom_path_parceles, 'r')
                        dummy = arxiu.readline()
                        lines = arxiu.readlines()
                        try:
                            """CreaciÃ³ de la taula temporal Resum_Temp_(data) de les dades del CSV de la taula resum de parceles"""
                            cur.execute(
                                "CREATE TABLE \"tr_temp" + Fitxer + "\" (\"Parcela\" varchar(20), \"Habitants\" numeric);")
                            conn.commit()
                            insert = ""
                            for linia in lines:
                                vec = linia.split(';', 20)
                                insert += "INSERT INTO \"tr_temp" + Fitxer + "\" (\"Parcela\", \"Habitants\") VALUES ('" + \
                                          vec[0] + "', " + vec[1] + ");\n"
                            cur.execute(insert)
                            conn.commit()
                        except Exception as ex:
                            print("Problem reading csv")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print(message)
                            QMessageBox.information(None, "Error", "Problem reading csv")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)

                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet(
                                'border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return

                        arxiu.close()
                        arxiuLlegit = True
                    else:
                        print("No hi ha l'arxiu")
                        path = QFileDialog.getExistingDirectory(self.dlg,
                                                                "Busca la carpeta que contÃ© els arxius provinents del mÃ²dul TAULA RESUM",
                                                                Path_Inicial + "\\", QFileDialog.ShowDirsOnly)
                else:
                    print("Cancelat")
                    self.progress_changed(0)
                    self.dlg.setEnabled(True)
                    self.barraEstat_connectat()
                    return

        self.progress_changed(10)
        QApplication.processEvents()
        if self.dlg.Cmb_Metode.currentText() == "ILLES" and self.dlg.tabWidget.currentIndex() != 2:
            cur.execute("DROP TABLE IF EXISTS habitatge" + Fitxer + "")
            conn.commit()
            cur.execute("CREATE TABLE habitatge" + Fitxer + " AS " + sql)
            conn.commit()
        else:
            titol = capa.encode('utf8', 'strict')
            vlayer = QgsVectorLayer(uri.uri(False), titol.decode('utf8'), "postgres")
            if vlayer.isValid():
                crs = vlayer.dataProvider().sourceCrs()
                vlayer_temp = QgsVectorLayer(f"Polygon?crs={crs.authid()}", capa, "memory")
                vlayer_temp.setCrs(crs)
                vlayer_temp.dataProvider().addAttributes(vlayer.fields())
                vlayer_temp.updateFields()
                vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())
                vlayer_temp.updateExtents()
                vlayer = self.comprobarValidez(vlayer_temp)
                QApplication.processEvents()
                QgsProject.instance().addMapLayer(vlayer, False)
        QApplication.processEvents()

        self.progress_changed(20)
        if self.dlg.tabWidget.currentIndex() == 2 or self.dlg.Cmb_Metode.currentText() == "PARCELES":
            vlayer_resultat = vlayer
        else:
            '''AgregaciÃ³n en funciÃ³n del mÃ©todo de trabajo'''
            if self.dlg.Cmb_Metode.currentText() == "ILLES":
                '''Debido a que la agregaciÃ³n de parcelas con ILLES es muy costosa, utilizamos un procedimiento distinto
                en este caso. Para ello, se hace uso de una tabla intermedia que relaciona parcel con ILLES por atributo
                y no por geometrÃ­a'''
                try:
                    vlayer_resultat = self.agregacionIlles(Fitxer, indicador, uri)
                except Exception as ex:
                    print("Error en la agregaciÃ³nilles")
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print(message)
                    QMessageBox.information(None, "Error", "Error en la agregaciÃ³n")
                    conn.rollback()
                    self.progress_changed(0)
                    self.dlg.setEnabled(True)
                    self.barraEstat_connectat()
                    return
            else:
                try:
                    vlayer_resultat = self.agregacio(indicador, uri, vlayer)
                except Exception as ex:
                    print("Error en la agregacio")
                    template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                    message = template.format(type(ex).__name__, ex.args)
                    print(message)
                    QMessageBox.information(None, "Error", "Error en la agregaciÃ³n")
                    conn.rollback()
                    self.progress_changed(0)
                    self.dlg.setEnabled(True)
                    self.barraEstat_connectat()
                    return

            QApplication.processEvents()

        if self.dlg.tabWidget.currentIndex() == 0:
            self.progress_changed(95)
            vlayer_resultat.startEditing()
            vlayer_resultat.addAttribute(QgsField('Indicador', QVariant.Double))
            vlayer_resultat.commitChanges()
            vlayer_resultat.updateFields()

            '''CÃ¡lculo del Indicador'''
            self.calculateIndicador(vlayer_resultat)

        self.cleanResultInFinquesAnyConstruccio(indicador, vlayer_resultat)

        self.checkDuplexInMapaAlcades(indicador, vlayer_resultat)

        self.correctHabitantsHabitatge(vlayer_resultat)

        #QgsProject.instance().addMapLayer(vlayer_resultat).setName("Resultat abans de mostraLayerPerPantalla")

        self.mostraLayerPerPantalla(vlayer_resultat)
        if vlayer is not None:
            QgsProject.instance().removeMapLayers([vlayer.id()])

        QApplication.processEvents()
        iface.mapCanvas().refresh()
        drop = ''
        drop += 'DROP TABLE IF EXISTS "tr_temp' + Fitxer + '";\n'
        drop += 'DROP TABLE IF EXISTS habitatge' + Fitxer + ';\n'
        drop += 'DROP TABLE IF EXISTS mapa_alcades' + Fitxer + ';\n'
        drop += 'DROP TABLE IF EXISTS parcel_temp;\n'
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
            print("Error DROP final")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print(message)
            QMessageBox.information(None, "Error", "Error DROP final")
            conn.rollback()
            self.progress_changed(0)
            self.dlg.setEnabled(True)
            self.barraEstat_connectat()
        self.progress_changed(100)
        self.barraEstat_connectat()
        self.dlg.setEnabled(True)

    def agregacionIlles(self, Fitxer, indicador, uri):
        # He creat parcel_zone a la nova refactored per tenir-la ja creada
        if indicador == 'DensitatHabitantsHabitatge':
            f"""
            (
                SELECT
                    zone.id_zone,
                    zone.geom,
                    zone.cadastral_zoning_reference,
                    SUM(hab."Habitants"::INTEGER) AS "Habitants",
                    SUM(hab."SupCons"::INTEGER) AS "SupCons"
                FROM
                    zone
                    JOIN parcel_zone
                        ON (zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference)
                    JOIN habitatge{Fitxer} AS hab
                        ON (parcel_zone.cadastral_reference = hab.cadastral_reference)
                WHERE
                    zone.cadastral_zoning_reference NOT LIKE ''
                GROUP BY
                    zone.id_zone,
                    zone.geom,
                    zone.cadastral_zoning_reference
            )
            """
            query = f"""(SELECT zone.id_zone, zone.geom, zone.cadastral_zoning_reference, SUM(hab."Habitants"::INTEGER) AS "Habitants", SUM(hab."SupCons"::INTEGER) AS "SupCons" FROM zone JOIN parcel_zone ON zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference JOIN habitatge{Fitxer} AS hab ON parcel_zone.cadastral_reference = hab.cadastral_reference WHERE zone.cadastral_zoning_reference NOT LIKE '' GROUP BY zone.id_zone, zone.geom, zone.cadastral_zoning_reference)"""
            uri.setDataSource("", query, "geom", "", "id_zone")
            vlayer_resultat = QgsVectorLayer(uri.uri(), "Resum", "postgres")
            vlayer_resultat = self.comprobarValidez(vlayer_resultat)
        elif indicador == "FinquesAnyConstruccio":
            if self.dlg.mitjanaRadioButton.isChecked():
                f"""
                (
                    SELECT
                        zone.id_zone,
                        zone.geom,
                        zone.cadastral_zoning_reference,
                        SUM(hab."SCxAC"::INTEGER) AS "SCxAC",
                        SUM(hab."SupCons"::INTEGER) AS "SupCons"
                    FROM
                        zone
                        JOIN parcel_zone
                            ON (zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference)
                        JOIN habitatge{Fitxer} AS hab
                            ON (parcel_zone.cadastral_reference = hab.cadastral_reference)
                    WHERE
                        zone.cadastral_zoning_reference NOT LIKE '' AND zone.type LIKE '%MAN%'
                    GROUP BY
                        zone.id_zone,
                        zone.geom,
                        zone.cadastral_zoning_reference
                )
                """
                query = f"""(SELECT zone.id_zone, zone.geom, zone.cadastral_zoning_reference, SUM(hab."SCxAC"::INTEGER) AS "SCxAC", SUM(hab."SupCons"::INTEGER) AS "SupCons" FROM zone JOIN parcel_zone ON zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference JOIN habitatge{Fitxer} AS hab ON parcel_zone.cadastral_reference = hab.cadastral_reference WHERE zone.cadastral_zoning_reference NOT LIKE '' AND zone.type LIKE '%MAN%' GROUP BY zone.id_zone, zone.geom, zone.cadastral_zoning_reference)"""

                uri.setDataSource("", query, "geom", "", "id_zone")
                vlayer_resultat = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
                vlayer_resultat = self.comprobarValidez(vlayer_resultat)

                vlayer_resultat = self.MediaPonderada(vlayer_resultat)
            else:
                vlayer_resultat = self.modaPonderadaIlles(Fitxer, uri)

        else:
            f"""
            (
                SELECT
                    zone.id_zone,
                    zone.geom,
                    zone.cadastral_zoning_reference,
                    SUM(hab."SupCons"::INTEGER) AS "SupCons"
                FROM
                    zone
                    JOIN parcel_zone
                        ON (zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference)
                    JOIN habitatge{Fitxer} AS hab
                        ON (parcel_zone.cadastral_reference = hab.cadastral_reference)
                WHERE
                    zone.cadastral_zoning_reference NOT LIKE ''
                GROUP BY
                    zone.id_zone,
                    zone.geom,
                    zone.cadastral_zoning_reference
            )
            """
            query = f"""(SELECT zone.id_zone, zone.geom, zone.cadastral_zoning_reference, SUM(hab."SupCons"::INTEGER) AS "SupCons" FROM zone JOIN parcel_zone ON (zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference) JOIN habitatge{Fitxer} AS hab ON (parcel_zone.cadastral_reference = hab.cadastral_reference) WHERE zone.cadastral_zoning_reference NOT LIKE '' GROUP BY zone.id_zone, zone.geom, zone.cadastral_zoning_reference)"""
            uri.setDataSource("", query, "geom", "", "id_zone")
            vlayer_resultat = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
        
        crs = vlayer_resultat.dataProvider().sourceCrs()
        vlayer_resultat_temp = QgsVectorLayer("Polygon", self.dlg.Cmb_Metode.currentText() + " " + self.getUnitats(), "memory")
        vlayer_resultat_temp.setCrs(crs)
        vlayer_resultat_temp.dataProvider().addAttributes(vlayer_resultat.fields())
        vlayer_resultat_temp.updateFields()
        vlayer_resultat_temp.dataProvider().addFeatures(vlayer_resultat.getFeatures())
        vlayer_resultat = self.comprobarValidez(vlayer_resultat_temp)
        return vlayer_resultat

    def modaPonderadaIlles(self, Fitxer, uri):
        f"""
        (
            SELECT
                hab.id_parcel,
                hab.cadastral_reference,
                hab."SupCons",
                hab.date_of_construction,
                hab.geom,
                zone.id_zone AS id_agrupat,
                zone.cadastral_zoning_reference
            FROM
                zone
                JOIN parcel_zone
                    ON (zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference)
                JOIN habitatge{Fitxer} AS hab
                    ON (parcel_zone.cadastral_reference = hab.cadastral_reference)
            WHERE
                zone.cadastral_zoning_reference NOT LIKE '' AND zone.type LIKE '%MAN%'
        )
        """
        query = f"""(SELECT hab.id_parcel, hab.cadastral_reference, hab."SupCons", hab.date_of_construction, hab.geom, zone.id_zone AS id_agrupat, zone.cadastral_zoning_reference FROM zone JOIN parcel_zone ON zone.cadastral_zoning_reference = parcel_zone.cadastral_zoning_reference JOIN habitatge{Fitxer} AS hab ON parcel_zone.cadastral_reference = hab.cadastral_reference WHERE zone.cadastral_zoning_reference NOT LIKE '' AND zone.type LIKE '%MAN%')"""
        uri.setDataSource("", query, "geom", "", "id_parcel")
        ###uri.setDataSource("", query, "geom", "", "id_agrupat")
        vlayer_resultat = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
        vlayer_resultat = self.comprobarValidez(vlayer_resultat)
        self.progress_changed(70)
        QApplication.processEvents()
        vlayer_resultat.startEditing()
        features = vlayer_resultat.getFeatures()
        for feature in features:
            if (feature.attribute("SupCons") == None) or feature.attribute("date_of_construction") == None:
                vlayer_resultat.deleteFeature(feature.id())
        vlayer_resultat.commitChanges()
        print("procesoModaPonderada 1")
        vlayer_calculat = self.procesoModaPonderada(vlayer_resultat)
        QgsProject.instance().addMapLayer(vlayer_calculat, False)
        uri.setDataSource("", "(SELECT * FROM zone WHERE cadastral_zoning_reference NOT LIKE '' AND cadastral_zoning_reference IS NOT NULL AND zone.type LIKE '%MAN%')", "geom", "", "id_zone")
        entitatResum = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
        entitatResum = self.comprobarValidez(entitatResum)
        QApplication.processEvents()
        QgsProject.instance().addMapLayer(entitatResum, False)
        self.progress_changed(75)
        vlayer_resultat = self.AgregacioQGIS(entitatResum, vlayer_calculat.id(), "intersects","SupCons", 6,"sum","modaPonderada2Atr", "first_value")
        self.progress_changed(80)
        QApplication.processEvents()
        QgsProject.instance().removeMapLayers([vlayer_calculat.id()])
        QgsProject.instance().removeMapLayers([entitatResum.id()])
        crs = vlayer_resultat.dataProvider().sourceCrs()
        print(f"crs: {crs} crs.authid(): {crs.authid()}")
        print(vlayer_resultat.geometryType())
        if vlayer_resultat.geometryType() == QgsWkbTypes.PolygonGeometry:
            tipus = "Polygon"
        elif vlayer_resultat.geometryType() == QgsWkbTypes.PointGeometry:
            tipus = "Point"
        elif vlayer_resultat.geometryType() == QgsWkbTypes.LineGeometry:
            tipus = "LineString"
        else:
            tipus = "NoGeometry"
        print(f"tipus: {tipus}")
        vlayer_resultat_temp = QgsVectorLayer(f"{tipus}?crs={crs.authid()}", self.dlg.Cmb_Metode.currentText() + " " + self.getUnitats(), "memory")
        vlayer_resultat_temp.setCrs(crs)

        vlayer_resultat_temp.dataProvider().addAttributes(vlayer_resultat.fields())
        vlayer_resultat_temp.updateFields()

        for feat in vlayer_resultat.getFeatures():
            #print(f"Feature: {feat.id()}, geometry: {feat.geometry()}")
            new_geom = feat.geometry()
            new_feat = QgsFeature()
            new_feat.setGeometry(new_geom)
            new_feat.setAttributes(feat.attributes())
            vlayer_resultat_temp.dataProvider().addFeature(new_feat)

        '''features = vlayer_resultat.getFeatures()
        features_list = []
        for feature in features:
            new_feat = QgsFeature(feature)
            if new_feat.hasGeometry():
                features_list.append(new_feat)
            else:
                print(f"Warning: feature {feature.id()} has no geometry")
        
        vlayer_resultat_temp.dataProvider().addFeatures(features_list)

        #vlayer_resultat_temp.dataProvider().addFeatures(vlayer_resultat.getFeatures())
        '''
        vlayer_resultat_temp.updateExtents()
        vlayer_resultat = self.comprobarValidez(vlayer_resultat_temp)
        return vlayer_resultat

    def agregacio(self, indicador, uri, vlayer):
        if self.dlg.Cmb_Metode.currentText() == "ILLES":
            uri.setDataSource("", "(SELECT * FROM zone WHERE cadastral_zoning_reference NOT LIKE '' AND cadastral_zoning_reference IS NOT NULL)", "geom", "", "id_zone")
        elif self.dlg.Cmb_Metode.currentText() == "PARCELES":
            uri.setDataSource("", "(SELECT * FROM parcel_temp)", "geom", "", "id_parcel")
        elif self.dlg.Cmb_Metode.currentText() == "SECCIONS":
            uri.setDataSource("", "(SELECT * FROM seccions)", "geom", "", "id")
        elif self.dlg.Cmb_Metode.currentText() == "BARRIS":
            uri.setDataSource("", "(SELECT * FROM barris)", "geom", "", "id")
        elif self.dlg.Cmb_Metode.currentText() == "DISTRICTES POSTALS":
            uri.setDataSource("", "(SELECT * FROM districtes_postals)", "geom", "", "id")
        elif self.dlg.Cmb_Metode.currentText() == "SECTORS":
            uri.setDataSource("", "(SELECT * FROM sectors)", "geom", "", "id")
        else:
            uri.setDataSource("", "(SELECT * FROM districtes)", "geom", "", "id")
        entitatResum = QgsVectorLayer(uri.uri(False), "Resum", "postgres")
        entitatResum = self.comprobarValidez(entitatResum)
        QApplication.processEvents()
        #QgsProject.instance().addMapLayer(entitatResum, False)
        QgsProject.instance().addMapLayer(entitatResum).setName("entitatResum linia 1672")
        if indicador == "FinquesAnyConstruccio":
            if self.dlg.mitjanaRadioButton.isChecked():
                vlayer_resultat = self.AgregacioQGIS(entitatResum, vlayer.id(), "intersects", "SupCons", 6, "sum", indicador, "first_value")
                vlayer_resultat = self.MediaPonderada(vlayer_resultat)
            else:
                #if self.dlg.Cmb_Metode.currentText() == "ILLES":
                #    vlayer_resultat = self.AgregacioQGIS(vlayer, entitatResum.id(), "intersects", "id_zone", 4, "concatenate", "modaPonderada", "first_value")
                #elif self.dlg.Cmb_Metode.currentText() == "PARCELES":
                #    vlayer_resultat = self.AgregacioQGIS(vlayer, entitatResum.id(), "intersects", "id_parcel", 4, "concatenate", "modaPonderada", "first_value")
                #else:
                #    vlayer_resultat = self.AgregacioQGIS(vlayer, entitatResum.id(), "intersects", "id", 4, "concatenate", "modaPonderada", "first_value")
                vlayer_resultat = self.AgregacioQGIS(vlayer, entitatResum.id(), "intersects", "id", 4, "concatenate", "modaPonderada", "first_value")
                self.progress_changed(70)
                QApplication.processEvents()

                vlayer_resultat.startEditing()
                features = vlayer_resultat.getFeatures()
                for feature in features:
                    if (feature.attribute("SupCons") == None) or feature.attribute("date_of_construction") == None:
                        vlayer_resultat.deleteFeature(feature.id())
                vlayer_resultat.commitChanges()
                
                print("procesoModaPonderada 2")
                vlayer_calculat = self.procesoModaPonderada(vlayer_resultat)

                QgsProject.instance().addMapLayer(vlayer_calculat, False)

                vlayer_resultat = self.AgregacioQGIS(entitatResum, vlayer_calculat.id(), "intersects", "SupCons", 6,
                                                     "sum",
                                                     "modaPonderada2", "first_value")
                QgsProject.instance().removeMapLayers([vlayer_calculat.id()])
        else:
            vlayer_resultat = self.AgregacioQGIS(entitatResum, vlayer.id(), "intersects", "SupCons", 6, "sum",
                                                 indicador, "first_value")
        QApplication.processEvents()
        QgsProject.instance().removeMapLayers([entitatResum.id()])
        crs = vlayer_resultat.dataProvider().sourceCrs()
        if str(vlayer_resultat.geometryType()) == "GeometryType.Polygon":
            tipus = "Polygon"
        elif str(vlayer_resultat.geometryType()) == "GeometryType.Point":
            tipus = "Point"
        elif str(vlayer_resultat.geometryType()) == "GeometryType.Line":
            tipus = "LineString"
        else:
            tipus = "NoGeometry"
        vlayer_resultat_temp = QgsVectorLayer(tipus, self.dlg.Cmb_Metode.currentText() + " " + self.getUnitats(), "memory")
        vlayer_resultat_temp.setCrs(crs)
        vlayer_resultat_temp.dataProvider().addAttributes(vlayer_resultat.fields())
        vlayer_resultat_temp.updateFields()
        vlayer_resultat_temp.dataProvider().addFeatures(vlayer_resultat.getFeatures())
        vlayer_resultat_temp.updateExtents()
        vlayer_resultat = self.comprobarValidez(vlayer_resultat_temp)
        return vlayer_resultat

    def calculateIndicador(self, vlayer_resultat):
        vlayer_resultat.startEditing()
        features = vlayer_resultat.getFeatures()
        index = self.getIndexField(vlayer_resultat, "Indicador")
        supConsTotal = 0
        unitatTotal = 0
        for feature in features:
            if feature.attribute("SupCons") is None:
                vlayer_resultat.deleteFeature(feature.id())
                continue
            
            

            if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge':
                habitants = feature.attribute("Habitants")
                if type(habitants) is QVariant:
                    habitants = habitants.Double
                else:
                    habitants = float(habitants)
                unitat = int(habitants)
            else:
                unitat = float(feature.geometry().area())

            supCons = feature.attribute("SupCons")
            if type(supCons) is QVariant:
                supCons = supCons.Double
            else:
                supCons = float(supCons)
            if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatPlanta0Area' and supCons > float(
                    feature.geometry().area()):
                supCons = float(feature.geometry().area())

            inverse = self.dlg.inverse_ratio.isChecked()
            if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge':
                inverse = not inverse

            if not inverse:
                if unitat == 0:
                    value = 0
                else:
                    value = supCons / unitat
            else:
                if supCons == 0:
                    value = 0
                else:
                    value = unitat / supCons
            supConsTotal += supCons
            unitatTotal += unitat
            vlayer_resultat.changeAttributeValue(feature.id(), index, value)
        '''MEDIA'''
        self.calculateMedia(index, supConsTotal, unitatTotal, vlayer_resultat)
        vlayer_resultat.commitChanges()

    def calculateMedia(self, index, supConsTotal, unitatTotal, vlayer_resultat):
        if self.dlg.checkbox_media.isChecked() and self.dlg.tabWidget.currentIndex() == 0:
            inverse = self.dlg.inverse_ratio.isChecked()
            if self.dlg.tabWidget.currentIndex() == 0 and self.dlg.comboIndicador.currentText() == 'DensitatHabitantsHabitatge':
                inverse = not inverse

            if not inverse:
                if unitatTotal == 0:
                    media = 0
                else:
                    media = supConsTotal / unitatTotal
            else:
                if supConsTotal == 0:
                    media = 0
                else:
                    media = unitatTotal / supConsTotal
            if media != 0:
                for feature in vlayer_resultat.getFeatures():
                    vlayer_resultat.changeAttributeValue(feature.id(), index,
                                                         feature.attribute("Indicador") / media * 100)

    def correctHabitantsHabitatge(self, vlayer_resultat):
        if self.getUnitats() == "hab/mÂ² x 10000":
            vlayer_resultat.startEditing()
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "Indicador")
            for feature in features:
                value = float(feature.attribute("Indicador")) * 10000
                vlayer_resultat.changeAttributeValue(feature.id(), index, value)
            vlayer_resultat.commitChanges()

    def cleanResultInFinquesAnyConstruccio(self, indicador, vlayer_resultat):
        if indicador == "FinquesAnyConstruccio":
            vlayer_resultat.startEditing()
            if self.dlg.mitjanaRadioButton.isChecked():
                vlayer_resultat.deleteAttribute(self.getIndexField(vlayer_resultat, "SCxAC"))
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "date_of_construction")
            for feature in features:
                #if (feature.attribute("SupCons") == None) or feature.attribute("date_of_construction") == None:
                if (feature.attribute("SupCons") == None) or feature.attribute("date_of_construction") == None:
                    vlayer_resultat.deleteFeature(feature.id())
                vlayer_resultat.changeAttributeValue(feature.id(), index, str(feature.attribute("date_of_construction"))[:4])
            vlayer_resultat.commitChanges()

    def checkDuplexInMapaAlcades(self, indicador, vlayer_resultat):
        if indicador == "MapaAlÃ§adesParcelÂ·la":
            vlayer_resultat.startEditing()
            features = vlayer_resultat.getFeatures()
            index = self.getIndexField(vlayer_resultat, "Indicador")
            for feature in features:
                if feature.attribute("SupCons") > float(feature.geometry().area()):
                    vlayer_resultat.changeAttributeValue(feature.id(), index, feature.attribute("Indicador") + 1)
                if feature.attribute("floor") == "AT":
                    vlayer_resultat.changeAttributeValue(feature.id(), index, feature.attribute("Indicador") + 1)
            vlayer_resultat.deleteAttribute(self.getIndexField(vlayer_resultat, "floor"))
            vlayer_resultat.commitChanges()

    # Processing feedback
    def progress_changed(self, progress):
        self.dlg.progressBar.setValue(progress)

    def AgregacioQGIS(self, Entitat_Resum, Entitat_Detall, operacion, camp, tipus, operacio_aggregate, indicador,
                      aggregate):
        f = QgsProcessingFeedback()
        f.progressChanged.connect(self.progress_changed)
        if (Qgis.QGIS_VERSION_INT < 30600):
            sortida = 'memory:'
        else:
            sortida = 'TEMPORARY_OUTPUT'
        alg = {
            'FIELD_LENGTH': 80,
            'FIELD_NAME': 'UUID',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': 'uuid()',
            'INPUT': Entitat_Resum,
            'NEW_FIELD': True,
            'OUTPUT': sortida
        }
        ILLES_UNIQUE = processing.run('qgis:fieldcalculator', alg)  # , feedback=f)

        operador = operacio_aggregate
        if indicador == 'DensitatHabitantsHabitatge':
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                               {'aggregate': 'first_value',
                                'delimiter': ',',
                                'input': 'aggregate( \'' + Entitat_Detall + '\', \'sum\',\"Habitants\", intersects( $geometry , geometry( @parent)))',
                                'length': 0,
                                'name': 'Habitants',
                                'precision': 0,
                                'type': 2}],
                'OUTPUT': sortida
            }
        elif indicador == "FinquesAnyConstruccio":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                               {'aggregate': 'first_value',
                                'delimiter': ',',
                                'input': 'aggregate( \'' + Entitat_Detall + '\', \'sum\',\"SCxAC\", intersects( $geometry , geometry( @parent)))',
                                'length': 0,
                                'name': 'SCxAC',
                                'precision': 0,
                                'type': 2}],
                'OUTPUT': sortida
            }
        elif indicador == "modaPonderada":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_string(\"' + camp + '\"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': 0,
                                'name': camp + "_agrupat",
                                'precision': 0,
                                'type': tipus
                                }],
                'OUTPUT': sortida
            }
            camp = camp + "_agrupat"
        elif indicador == "modaPonderada2":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:="' + camp + '", filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                               {'aggregate': 'first_value',
                                'delimiter': ',',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'max\',expression:=\"Any\", filter:=intersects( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': 0,
                                'name': 'date_of_construction',
                                'precision': 0,
                                'type': 2}],
                'OUTPUT': sortida
            }
        elif indicador == "modaPonderada2Atr":
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                #'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:="' + camp + '", filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:="' + camp + '", filter:="cadastral_zoning_reference"=attribute(@parent,\'cadastral_zoning_reference\'),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                },
                               {'aggregate': 'first_value',
                                'delimiter': ',',
                                #'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'max\',expression:=\"Any\", filter:=intersects( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'max\',expression:=\"Any\", filter:="cadastral_zoning_reference"=attribute(@parent,\'cadastral_zoning_reference\'),concatenator:=\'-\')',
                                'length': 0,
                                'name': 'date_of_construction',
                                'precision': 0,
                                'type': 2}],
                'OUTPUT': sortida
            }
        else:
            alg_params = {
                # Entitat Resum
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'GROUP_BY': 'UUID',
                'AGGREGATES': [{'aggregate': 'first_value',
                                'delimiter': ';',
                                'input': 'UUID',
                                'length': 80,
                                'name': 'UUID',
                                'precision': 0,
                                'type': 10
                                },
                               {'aggregate': aggregate,
                                'delimiter': ';',
                                'input': 'aggregate(layer:=\'' + Entitat_Detall + '\', aggregate:=\'' + operador + '\',expression:=to_real("' + camp + '"), filter:=' + operacion + '( $geometry , geometry( @parent)),concatenator:=\'-\')',
                                'length': -1,
                                'name': camp,
                                'precision': -1,
                                'type': tipus
                                }],
                'OUTPUT': sortida
            }

        pep = processing.run('qgis:aggregate', alg_params, feedback=f)

        if indicador == 'DensitatHabitantsHabitatge':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "Habitants"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        elif indicador == 'FinquesAnyConstruccio':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "SCxAC"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        elif indicador == 'modaPonderada2' or indicador == 'modaPonderada2Atr':
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp, "date_of_construction"],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        else:
            alg = {
                'INPUT': ILLES_UNIQUE['OUTPUT'],
                'FIELD': 'UUID',
                'INPUT_2': pep['OUTPUT'],
                'FIELD_2': 'UUID',
                'FIELDS_TO_COPY': [camp],
                'METHOD': 1,
                'DISCARD_NONMATCHING': False,
                'PREFIX': '',
                'OUTPUT': sortida
            }
        pep2 = processing.run('native:joinattributestable', alg)  # , feedback=f)

        alg = {
            'INPUT': pep2['OUTPUT'],
            'COLUMN': 'UUID',
            'OUTPUT': sortida
        }

        pep3 = processing.run('qgis:deletecolumn', alg)  # , feedback=f)
        return pep3['OUTPUT']

    def barraEstat_processant(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Processant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: rgb(255, 125, 155)')
        self.dlg.lblEstatConn.setText("Processant...")
        QApplication.processEvents()

    def barraEstat_noConnectat(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "No connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
        self.dlg.lblEstatConn.setText('No connectat')
        QApplication.processEvents()

    def barraEstat_connectat(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
        self.dlg.lblEstatConn.setText('Connectat')
        QApplication.processEvents()

    def barraEstat_connectant(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Connectant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ffff7f')
        self.dlg.lblEstatConn.setText('Connectant...')
        QApplication.processEvents()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        '''for action in self.actions:
            self.iface.removePluginMenu(
                self.tr('&exemple'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar'''
        for action in self.actions:
            self.iface.removePluginMenu('&CCU', action)
            self.toolbar.removeAction(action)

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.estatInicial()
        self.dlg.show()
        conn = self.getConnections()
        # Run the dialog event loop
        self.populateComboBox(self.dlg.comboConnexio, conn, 'Selecciona connexiÃ³', True)
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
